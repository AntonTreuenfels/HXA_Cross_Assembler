# Hobby Cross-Assembler (HXA) V0.201 - Code Generator and Related Functions

# (c) 2004-2013 by Anton Treuenfels

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# ---------------------------------

# by Anton Treuenfels

# 5248 Horizon Dr
# Fridley, MN 55421

# e-mail: hxa@earthlink.net

# source language: Thompson AWK 4.0

# first created: 03/22/03
# last revision: 09/12/13

# public function prefix: "CG"

# ----------------------------

# CPU name

local cpuName = ""

# CPU native byte order flag

local lsbFirst = 0              # thus MSB first if no cpu specified

# intermediate data storage

local dataNdx = 0

local dataType
local dataVal

# relate source line and data it generated

local dataLoc           # the data generated by this source line
local dataSrc           # the source line that generated this data
local dataAddr          # the starting address of object data
local dataList          # address (if any) of non-object data (for listing)

local lastSrc = 0       # most recent source line that stored data

# object size

local objectBytes

# 8-, 16- and 32-bit "byte" support

local byteSize = 1      # 1, 2 or 4 8-bit values in a "byte"

local padChar = "\x00"  # ...we may allow this to change in future versions

local charFmt           # output format of a single 8-bit char

# source listing support

local addrBase              # base address of first data generated by line
local addrOffset            # offset to remaining data from same line
local strData               # string data to break up during listing
local strOffset             # offset to remaining string data
local strChunkSize = 4      # four bytes (32 bits) - here for clarity

# data storage byte sizes

local dataSize              # number of "bytes" a data type occupies

local customSeq             # custom byte extraction sequence (not LSB/MSB)
local haveCustom            # flag: there is at least one custom sequence

# output data

local outFile           # output file
local outputSeq         # output sequence

# hexadecimal output file

local hexAddrType       # address type (16-, 20-, 24- or 32-bit)

local hexChkSum         # checksum of output line

local hexChunkSize = 16 # data size of an output line
local hexRecCount       # count of data records output

local hexStartExpr      # start address expression (if any)
local hexStartAddr      # start address value

local hexRecChar        # hex record line start character

# Intel hex file

local hexExtAddr        # extended address value (if any)
# local hexStartType    # start address type (if needed, = hexAddrType + 1)

# default output over-rides

local outputOverride    # most often by ASSUME psop

# -------------------------

# get octet count of a data type
# - ie., the number of 8-bit values the type represents

local function octets_in(type) { return( dataSize[type] * byteSize ) }

# convert a "byte" count to actual number of bits used by a data type

local function bits_in(bytes) { return( bytes * 8 * byteSize ) }

# create a custom byte extraction sequence

global function CGbyteseq(name, order) {

    local cnt
    local byte

    # type legal for current cpu ?
    # - never if cpu not initialized yet (got here via ASSUME psop)

    name = toupper( name )
    if ( !(name in dataSize) )
        UMignored( name )

    else {

        # we verify we have the correct number of legal characters,
        # but do not guarantee there are no duplicates

        cnt = octets_in( name )
        if ( (order !~ /^[0-3]+$/) || (split(order, byte, "") != cnt) )
            UMignored( order )

        # first time altered ?

        else if ( CKunique(order, name, outputOverride) ) {

            # create the shift sequence

            do {
                customSeq[ name ][ cnt ] = byte[ cnt ] * 8
            } while ( --cnt )

            # make sure whole family is altered

            customSeq[ "U" name ] = customSeq[ "S" name ] = \
                customSeq[ "R" name ] = customSeq[ name ]

            haveCustom = TRUE
        }
    }
}

# make one "family" of "-BIT--" data types
# - dynamic creation means which are available and what aliases refer
# to which types differ based on the size of a "byte"

local function maketype(bytes, native, alias) {

    local bits
    local name, uname, sname, rname

    bits = bits_in( bytes )

    if ( bits <= 32 ) {

        name = sprintf( native ? "BIT%02d" : "BIT%02dR", bits )

        name  = PSaddbitop( "",  name, alias )
        uname = PSaddbitop( "U", name, alias )
        sname = PSaddbitop( "S", name, alias )
        rname = PSaddbitop( "R", name, alias )

        dataSize[ name ] = dataSize[ uname ] = \
            dataSize[ sname ] = dataSize[ rname ] = bytes
    }
}

# cpu initialization error

local function badcpu(this) { UMwarn( "BadCPU", this ) }

# initialize generalized cpu data from a description

local function setcpu(this) {

    local descrip
    local pcbits, chpad

    # description itself okay ?

    descrip = toupper( INSgetdescrip(this) )
    if ( descrip !~ /^T_[0-9][0-9]_[LM](08|16|32)?$/ ) {
        badcpu( descrip )
        return( FALSE )
    }

    # how many bits in program counter ?
   
    pcbits = substr( descrip, 3, 2 ) + 0
    if ( CKinrange(pcbits, 8, 32) )
        PCsetwidth( pcbits )
    else {
        badcpu( descrip )
        return( FALSE )
    }

    # LSB or MSB processor ?

    lsbFirst = descrip ~ /L/

    # 16- or 32-bit "byte" ?

    if ( descrip ~ /16$/ )
        byteSize = 2
    else if ( descrip ~ /32$/ )
        byteSize = 4

    # make sure 8-bit chars are padded to full "byte" width

    chpad = strdup( padChar, byteSize - 1 )
    charFmt = lsbFirst ? "%c" chpad : chpad "%c"

    # create the "-BIT--" data storage psops that will be available

    maketype( 1, TRUE,  "BYTE" )
    maketype( 2, TRUE,  "WORD" )
    maketype( 2, FALSE, "REVWORD" )
    maketype( 3, TRUE,  "" )
    maketype( 3, FALSE, "" )
    maketype( 4, TRUE,  "LONG" )
    maketype( 4, FALSE, "REVLONG" )

    # okay

    return( TRUE )
}

# -------------------------

# get CPU name

global function CGgetcpu() { return( cpuName ) }

# handle "CPU" psop

global function CGdocpu(this) {

    # not a known cpu ?

    this = toupper( this )
    if ( !INSiscpu(this) )
        badcpu( this )

    # cpu already set ?

    else if ( CGgetcpu() )
        CKsameval( this, CGgetcpu() )

    # try to initialize
    # - cpu-independant parts get set first so if cpu-dependant
    # parts want to make changes (eg., byte extraction order)
    # they can be better error-checked

    else if ( setcpu(this) ) {
        INSsetcpu( this )
        cpuName = this
    }
}

# -------------------------
# Pass One-only functions
# -------------------------

# get size of data at given storage index

local function sizeat(i) {

    local type

    if ( (type = dataType[i]) != "STRNG" )
        return( dataSize[type] )

    return( length(dataVal[i]) / byteSize )
}

# save object data in intermediate form

global function CGsavedata(type, val) {

    local srcline

    # save data type and value

    ++dataNdx
    dataType[ dataNdx ] = type
    dataVal[ dataNdx ]  = val

    # if this is first object data generated by current source line,
    # save the connections between it and source text that generated it
    # - also save the data's address

    srcline = SRCgetmaster()
    if ( srcline != lastSrc ) {
        dataLoc[ srcline ]  = dataNdx
        dataSrc[ dataNdx ]  = srcline
        dataAddr[ dataNdx ] = PCread()
        SRCremember()
        lastSrc = srcline
    }

    # update program counter and object size

    val = sizeat( dataNdx )
    PCadd( val )
    objectBytes += val
}

# save non-object data in intermediate form
# - saved in the same data structure as object data in order to make it
# easy to list
# - a separate function so we don't have to worry about whether or not
# the program counter is currently valid for data storage

local function savenonobjectdata(addr, type, val) {

    local srcline

    # save data type and value

    ++dataNdx
    dataType[ dataNdx ] = type
    dataVal[ dataNdx ]  = val

    # if this is first non-object data generated by current source line,
    # save the connections between it and source text that generated it
    # - "addr" is saved in "dataList[]", not "dataAddr[]"
    # - we use the absence of an entry in "dataAddr[]" at this index
    # as a flag to indicate non-object data

    srcline = SRCgetmaster()
    if ( srcline != lastSrc ) {
        dataLoc[ srcline ]  = dataNdx
        dataSrc[ dataNdx ]  = srcline
        dataList[ dataNdx ] = addr
        SRCremember()
        lastSrc = srcline
    }
}

# save non-object numeric data

global function CGsavenonobjnum(addr, num) {

    # "BIT32" is always valid no matter what "byte" size is

    savenonobjectdata( addr, "BIT32", num )
}

# save non-object string data

global function CGsavenonobjstr(addr, str) {

    local val

    # display only first few chars (one line) in OBJECT section
    # - full value will still appear in SYMBOL section
    # - if string is null string, we substitute a printable value so users
    # (mostly listing functions) are happy

    if ( str )
        val = substr( str, 1, strChunkSize )
    else
        val = "\0"

    savenonobjectdata( addr, "STRNG", val )
}

# check whether or not assertion is true

local function checkassert(val) {

    if ( !val )
        UMerror( "BadAssert" )
}

# save and possibly check non-object ASSERT data
# - checked on first pass (if resolved then) or second (if resolved then)

global function CGcheckassert(val) {

    # saving is only necessary if not resolved during first pass,
    # but listing looks better if we always save

    savenonobjectdata( 0, "ASSRT", val )
    if ( EXPgotnum(val) )
        checkassert( val )
}

# save string data

global function CGsavestr(data) {

    local cnt

    # make sure string is an integer multiple of byteSize in length
    # - some callers already do this, some don't

    cnt = length(data) % byteSize
    if ( cnt )
        data = data strdup( padChar, byteSize - cnt )

    while ( length(data) > 512 ) {
        CGsavedata( "STRNG", substr(data, 1, 512) )
        data = substr( data, 513 )
    }

    if ( data )
        CGsavedata( "STRNG", data )
}

# handle "STRING" and "STRINGR" pseudo ops
# - [label] STRING[R] const_num_or_str$ [[, const_num_or_str$]..]

global function CGdostr(type, str) {

    local i
    local fwd, ch
    local data
    local chr

    fwd = ( type == "STRING" )
    data = ""
    i = split( str, chr, "" )
    do {
        ch = sprintf( charFmt, CKchtonum(chr[i]) )
        if ( fwd )
            data = ch data      # builds right -> left
        else
            data = data ch      # builds left -> right
    } while ( --i )

    CGsavestr( data )
}

# fill block with constant string

global function CGfill(cnt, str) {

    local hex

    # create the string value to store

    if ( !str )
        str = padChar

    hex = strdup( str, int(512/length(str)) )

    # store the string value
    # - note counts less than one don't do anything

    cnt *= byteSize
    while ( length(hex) <= cnt ) {
        CGsavestr( hex )
        cnt -= length( hex )
    }

    if ( cnt > 0 )
        CGsavestr( substr(hex, 1, cnt) )
}

# record start address and show end address (if either)

global function CGsetstart(addr) {

    local val

    # no start expression ?

    if ( !addr ) {

        # does the program counter have a value now ?
        # - eg., segmented programs do not

        if ( PCcanget() )
            CGsavenonobjstr( PCget(), "" )
    }

    # there is a start expression

    if ( addr ) {

        hexStartExpr = ".T."
        val = EXPgetnum( addr )
        if ( CKok(val) )
            CGsavenonobjnum( PCcanget() ? PCget() : 0, val )
    }
}

# -------------------------

# "byte" extraction
# - we're limited a little by 32-bit max precision

# "<" operator: get least significant byte
# - returned in least significant byte position

global function CGgetlsb(val) {

    if ( byteSize == 1 )
        return( and(val, 0x00ff) )

    if ( byteSize == 2 )
        return( and(val, 0xffff) )

    # byteSize == 4

    return( val )
}

# ">" operator: get most significant byte of least significant word
# - returned in least significant byte position
# - unsigned 32-bit "byte" doesn't have one (so effectively zero)

global function CGgetmsb(val) {

    if ( byteSize == 1 )
        return( and(shiftr(val, 8), 0x00ff) )

    if ( byteSize == 2 )
        return( and(shiftr(val, 16), 0xffff) )

    return( 0 )
}

# "^" operator: get most significant word
# - returned in least significant word position
# - unsigned 16- and 32-bit "bytes" don't have one (so effectively zero)

global function CGgetmsw(val) {

    if ( byteSize == 1 )
        return( and(shiftr(val, 16), 0xffff) )

    return( 0 )
}

# -------------------------
# Pass Two-only functions
# -------------------------

# resolve and range check values

global function CGresolve() {

    local i, j
    local val, type, bits
    local firstndx, addr
    local minval, maxval

    # if no CPU was specified, 'dataSize' was not initialized,
    # no object code was saved and there is no need to list it
    # - however there may have been some NON-object code saved,
    # and we may need to list it

    if ( !CGgetcpu() )
        dataSize[ "BIT32" ] = 4

    # create range check values

    for ( type in dataSize ) {
        bits = bits_in( dataSize[type] )
        if ( type ~ /^[RS]/ ) {
            minval[ type ] = -2^(bits - 1)
            maxval[ type ] = 2^(bits - 1) - 1
        }
        else if ( type ~ /^U/ ) {
            minval[ type ] = 0
            maxval[ type ] = 2^bits - 1
        }
    }

    # data

    SRCsavemaster()

    for ( i = 1; i <= dataNdx; i++ ) {

        # check if value is already known

        if ( (type = dataType[i]) == "STRNG" )
            continue

        # if this is the first numeric data generated by a source line,
        # note its line number (for error-reporting)
        # - also note start index of this line (for resolving relative data)

        if ( i in dataSrc ) {
            SRCsetmaster( dataSrc[i] )
            firstndx = i
        }

        # make sure we have a resolved value

        val = dataVal[ i ]
        if ( !EXPgotnum(val) ) {
            val = EXPresolve( val )
            if ( !CKok(val) )
                continue
            dataVal[ i ] = val
        }

        # must-fit type ? (range checked)

        if ( type ~ /^[RSU]/ ) {

            # relative signed ? (must adjust)
            # - adjustment is based on the address following this data,
            # so we add the size of all data so far generated by this line
            # to its absolute starting address
            # - note that internal HXA modules can generate multiple data
            # types from one source line (ie., different sizes possible),
            # although users themselves cannot

            if ( type ~ /^R/ ) {
                if ( !PClegal(val) )
                    continue
                j = firstndx
                addr = PCgetabs( dataAddr[j] )
                do {
                    addr += sizeat( j )
                } while ( ++j <= i )
                val -= addr
                dataVal[ i ] = val
            }

            # range check

            CKinrange( val, minval[type], maxval[type] )
        }

        # check assertion ?

        else if ( type == "ASSRT" )
            checkassert( val )
    }

    SRCresetmaster()

    # start address (if any)
    # - if present, will always be the last dataVal[]
    # - the value won't actually be used unless there is segmented or linear
    # hex file output, but we always at least want to check for errors anyway
    
    if ( hexStartExpr ) {
        hexStartAddr = dataVal[ dataNdx ]
        if ( EXPgotnum(hexStartAddr) )
            PClegal( hexStartAddr )
    }
}

# ----------------------------
# Data Format Conversion
# ----------------------------

# 32-bit numeric data native order is LSB on Intel processors,
# but we portray them here MSB first because we use right shifts to extract

# bit#      31-24   23-16   15-8    7-0
# octet#      3       2       1      0

# default extraction sequences for built-in data types
# - custom extraction sequences may modify these

# -BIT08-:
# LSB:  b[1] = o[0]
# MSB:  b[1] = o[0]

# -BIT16-:
# LSB:  b[1] = o[0], b[2] = o[1]
# MSB:  b[1] = o[1], b[2] = o[0]

# -BIT24-:
# LSB:  b[1] = o[0], b[2] = o[1], b[3] = o[2]
# MSB:  b[1] = o[2], b[2] = o[1], b[3] = o[0]

# -BIT32-:
# LSB:  b[1] = o[0], b[2] = o[1], b[3] = o[2], b[4] = o[3]
# MSB:  b[1] = o[3], b[2] = o[2], b[3] = o[1], b[4] = o[1]

# convert a 32-bit value to one or more bytes, custom byte order

local function num2seq(cnt, val, shift) {

    local byte

    val = EXPint( val )

    do {
        byte[ cnt ] = and( shiftr(val, shift[cnt]), 0xff )
    } while ( --cnt )

    return( byte )
}

# convert a 32-bit value to one or more bytes, LSB first

local function num2lsb(cnt, val) {

    local lsb

    val = EXPint( val )

    lsb[ 1 ]  = and( val, 0xff )
    if ( --cnt ) {
        lsb[ 2 ] = and( shiftr(val, 8), 0xff )
        if ( --cnt ) {
            lsb[ 3 ] = and( shiftr(val, 16), 0xff )
            if ( --cnt )
                lsb[ 4 ] = and( shiftr(val, 24), 0xff )
        }
    }

    return( lsb )
}

# convert a 32-bit value to one or more bytes, MSB first

local function num2msb(cnt, val) {

    local msb

    val = EXPint( val )

    msb[ cnt ] = and( val, 0xff )
    if ( --cnt ) {
        msb[ cnt ] = and( shiftr(val, 8), 0xff )
        if ( --cnt ) {
            msb[ cnt ] = and( shiftr(val, 16), 0xff )
            if ( --cnt )
                msb[ 1 ] = and( shiftr(val, 24), 0xff )
        }
    }

    return( msb )
}

# convert a saved 32-bit data value to one or more byte values

local function num2bytes(i) {

    local type, val
    local cnt

    type = dataType[ i ]
    val  = dataVal[ i ]

    cnt = octets_in( type )

    if ( haveCustom && (type in customSeq) )        # custom order
        return( num2seq(cnt, val, customSeq[type]) )
    else if ( type !~ /R$/ )                        # native order
        return( lsbFirst ? num2lsb(cnt, val) : num2msb(cnt, val) )
    else                                            # reverse native order
        return( lsbFirst ? num2msb(cnt, val) : num2lsb(cnt, val) )
}

# convert a string data value to one or more byte values

local function str2bytes(this) {

    local i
    local chr, byte

    i = split( this, chr, "" )

    do {
        byte[ i ] = ord( chr[i] )
    } while ( --i )

    return( byte )
}

# convert a data value to byte values (all at once)

local function datacode(i) {

    if ( dataType[i] != "STRNG" )
        return( num2bytes(i) )

    return( str2bytes(dataVal[i]) )
}

# ----------------------------
# Source Listing Support
# ----------------------------

# convert a data value to byte values (strings in chunks)

global function CGdatacode(i) {

    # currently processing a string ?

    if ( strData )       
        return( str2bytes(substr(strData, strOffset+1, strChunkSize)) )

    # numeric data at this index

    return( num2bytes(i) )
}

# get address of listing data

global function CGdataaddr(ndx) { return( addrBase + addrOffset ) }

# check if data at index is relative value

global function CGreldata(ndx) { return( dataType[ndx] ~ /^R/ ) }

# get original absolute address relative data is based on

global function CGabsdata(ndx) {

    return( CGdataaddr(ndx) + dataVal[ndx] + sizeat(ndx) )
}

# set up a chunk of data for listing

local function initchunk(ndx) {

    addrOffset = strOffset = 0
    strData = ( dataType[ndx] == "STRNG" ) ? dataVal[ ndx ] : ""
}

# did a given source line generate listable data ?
# - zero if no, non-zero if yes

global function CGfirstdata(srcline) {

    local ndx, addr

    # if this source line is not in dataLoc, there is no associated data

    if ( !(srcline in dataLoc) )
        return( 0 )

    # recover the (non-zero) index of the associated data

    ndx = dataLoc[ srcline ]

    # initialize for generating listing data

    addr = ( ndx in dataAddr ) ? dataAddr[ ndx ] : dataList[ ndx ]
    addrBase = PCgetabs( addr )
    initchunk( ndx )

    return( ndx )
}

# did the current source line generate more data to list ?
# - zero means no, non-zero means yes

global function CGnextdata(ndx) {

    # are we processing a string ?
    # - if there is more data we don't advance data index because we're
    # still listing the same source line, but we do update the string and
    # address offsets to reflect where the next chunk of data is

    if ( strData ) {
        strOffset += strChunkSize
        if ( strOffset < length(strData) ) {
            addrOffset += strChunkSize / byteSize
            return( ndx )
        }
    }

    # advance data index and check to see if we've reached either
    # the end of all stored data or data for the next source line

    if ( (++ndx > dataNdx) || (ndx in dataSrc) )
        return( 0 )

    # one source line generated multiple data stores

    addrBase += sizeat( ndx-1 )
    initchunk( ndx )

    return( ndx )
}

# report number of object-generating items in data store

global function CGgetStoreCnt() { return( dataNdx - length(dataList) ) }

# report size of object

global function CGgetObjectSize() { return( objectBytes ) }

# ----------------------------
# File Output
# ----------------------------

# create data output sequence

local function make_output_seq() {

    local i
    local seg, ndx

    if ( dataNdx ) {

        # recover space ( source listing should be complete first !! )

        delete( dataLoc )
        delete( dataList )

        # sequence data for output
        # - works for both segmented and monolithic programs
        # - non-object data is screened out here

        for ( i = 1; i <= dataNdx; i++ ) {

            if ( i in dataSrc ) {
                if ( !(i in dataAddr) )
                    continue
                seg = PCgetseg( dataAddr[i] )
                ndx = ( seg in outputSeq ) ? length(outputSeq[seg]) : 0
            }

            outputSeq[ seg ][ ++ndx ] = i
        }

        # we don't need these any more

        delete( dataSrc )
        delete( dataAddr )

        # flag we've done the re-arrangement

        dataNdx = 0
    }

    # how many segments to output are there ?

    return( length(outputSeq) )
}

# ----------------------------------------
# Binary format-specific functions
# ----------------------------------------

local function init_b_output() { return( "obj" ) }

# output binary object code segment

local function put_binseg(segnum) {

    local i, j
    local elem_cnt, byte_cnt
    local data, dataseq

    dataseq = outputSeq[ segnum ]
    elem_cnt = length( dataseq )
    for ( i = 1; i <= elem_cnt; i++ ) {
        data = datacode( dataseq[i] )
        byte_cnt = length( data )
        for ( j = 1; j <= byte_cnt; j++ )
            printf( "%c", data[j] ) > outFile
    }
}

# ----------------------------

# convert byte array to hex string

local function bytes2hexstr(data) {

    local i
    local val
    local hex

    hex = ""
    i = length( data )
    do {
        val = data[ i ]
        hex = sprintf( "%02X", val ) hex
        hexChkSum += val
    } while ( --i )

    return( hex )
}

# initialize record start character for 8-, 16- and 32-bit "bytes"
# - Intel:    ":;<"
# - Motorola: "STU"

local function setrecinit(base) {

    hexRecChar = ord( base ) + int( byteSize/2 )
}

# output one line of hex file with trailing checksum

local function hexout(body, chksum) {

    printf( "%c%s%02X\n", hexRecChar, body, and(chksum, 0xff) ) > outFile
}

# ----------------------------------------
# Intel format-specific functions
# ----------------------------------------

# initialize Intel output

local function init_i_output() {

    # non-zero address type means extended addresses are used
    # - if extended addresses are used, start addresses have same type,
    # either linear or segmented (no mix or match option)

    hexAddrType = 0

    # default format overridden ?

    if ( "hexfile" in outputOverride )
        hexAddrType = (outputOverride["hexfile"] == "linear") ? 4 : 2

    # default format: program counter > 20 bits?

    else if ( PCwider(20) )
        hexAddrType = 4

    # ...program counter > 16 bits?

    else if ( PCwider(16) )
        hexAddrType = 2

    # set first character of each record (flags "byte" size)

    setrecinit( ":" )

    # filename extension

    return( "hex" )
}

# output one line in Intel hexadecimal object format (rev A, 1/6/88)
# format: |recmark|reclen|loadoffset|rectyp|data|checksum|
# recmark    = 03AH (Ascii colon, ':')
# reclen     = length of data field in bytes
# loadoffset = load offset of data bytes (= zero if not data record)
# rectyp     = record type
#  0            = data (16-, 20- and 32-bit)
#  1            = end of file (16-, 20- and 32-bit)
#  2            = extended segment address (20- and 32-bit)
#  3            = start segment address (20- and 32-bit)
#  4            = extended linear address (32-bit)
#  5            = start linear address (32-bit)
# data       = data bytes of absolute memory image
# checksum   = -(reclen+loadoffset+rectype+data)&0FFH (so total sum = 0)

local function write_i_hex(type, offset, data) {

    local cnt
    local hex

    hexChkSum = cnt = 0

    # the equivalent of 'hex = sprintf("%04X%02X", offset, type)'
    # - done this way so checksum gets updated "for free"

    hex = bytes2hexstr( num2msb(3, offset * 256 + type) )

    # all types but EOF contain data

    if ( type != 1 ) {
        hex = hex bytes2hexstr( data )
        cnt = length( data )
    }

    # create line body; checksum is 2's complement

    hexout( sprintf("%02X%s", cnt, hex), -(hexChkSum+cnt) )
}

# write Intel extended address record

local function write_i_extaddr(val) {

    local factor, msb16

    # technically we could always use just 2^16...

    factor = ( hexAddrType == 2 ) ? 2^4 : 2^16

   # if "addr" >= 2^31 then it is in floating point form
   # - if so we need "hexExtAddr" to also be in floating point form
   # so it can be used to create offset values
   # - hence this less-intuitive method of performing simple shifts

   hexExtAddr = val - val % factor
   msb16 = hexExtAddr / factor

   # write base address as 16 most significant bits of hexExtAddr

   write_i_hex( hexAddrType, 0, num2msb(2, msb16) )

   # set data records written since last address record to zero

   hexRecCount = 0
}

# copy part of Intel output data array to a new array

local function partialdata(orgdata, ndx, end) {

    local i
    local newdata

    i = 1
    while ( ndx <= end )
        newdata[ i++ ] = orgdata[ ndx++ ]

    return( newdata )
}

# "write Intel header record"
# - no such thing, really, but we can do some initialization anyway

local function write_i_bof() {

    hexRecCount = hexExtAddr = 0x10000
}

# write Intel data record

local function write_i_data(addr, data) {

    local offset, octets, excess, below64K

    # 16-bit address output ?

    if ( !hexAddrType )
        write_i_hex( 0, addr, data )

    # 20- or 32-bit address output

    else {

        # because the offset value of an address is 16 bits, we
        # write up to 64K before we must insert an extended address record
        # - apparently "64K" means 2^16 of the smallest addressable unit,
        # since that much of an offset from a base address is allowed
        # - in any case we only output about 32K "bytes" before inserting
        # a new extended address record (note that making sure this test
        # fails is how we "jump start" the first extended address record)
        # - we also test for "address jumps" up or down great enough
        # to require a new extended base address

        offset = addr - hexExtAddr
        if ( (++hexRecCount >= 0x08000/hexChunkSize) \
            || (offset >= 0x10000) || (offset < 0) ) {

            write_i_extaddr( addr )
            offset = addr - hexExtAddr
        }

        # is this data all within a 64K offset ?

        octets = length( data )
        excess = offset + octets/byteSize - 0x10000
        if ( excess <= 0 )
            write_i_hex( 0, offset, data )

        # no, one or more "bytes" are at an offset >= 64K

        else {            
            below64K = (octets - excess) * byteSize
            write_i_hex( 0, offset, partialdata(data, 1, below64K) )
            write_i_extaddr( hexExtAddr + 0x10000 )
            write_i_hex( 0, 0, partialdata(data, below64K+1, octets) )
        }           
    }
}

# write Intel hex start address and EOF records

local function write_i_eof(writestart) {

    local addr

    # write start address record ?    

    if ( writestart && hexStartExpr && hexAddrType ) {

        addr = hexStartAddr

        # 20-bit segmented start address must be in CS:IP (16:16) format
        # - we use "huge" format, with the most significant 16 bits
        # in CS and only the least significant 4 bits in IP

        if ( hexAddrType == 2 )
            addr = shiftl( and(addr, 0x0ffff0), 12 ) + and( addr, 0x0f )

        # 32-bit linear start address we don't have to alter

        write_i_hex( hexAddrType+1, 0, num2msb(4, addr) )
    }

    # write Intel hex EOF record

    write_i_hex( 1, 0, 0 )
}

# ----------------------------------------
# Motorola format-specific functions
# ----------------------------------------

# initialize Motorola output

local function init_m_output() {

    local ext

    if ( "srecfile" in outputOverride )
        ext = outputOverride[ "srecfile" ]
    else if ( PCwider(24) )
        ext = "S37"
    else if ( PCwider(16) )
        ext = "S28"
    else
        ext = "S19"

    # extract first digit to use as address type

    hexAddrType = substr( ext, 2, 1 ) + 0

    # set initial char of each record

    setrecinit( "S" )

    # filename extension

    return( ext )
}

# output one line in Motorola hexadecimal object format
# format: |rectype|count|absaddr|data|checksum|
# rectyp     = record type
#  'S0'       = header
#  'S1'       = absaddr is 16-bit start load address
#  'S2'       = absaddr is 24-bit start load address
#  'S3'       = absaddr is 32-bit start load address
#  'S5'       = absaddr is 16-bit count of previous records of types S1-S3
#  'S6'       = absaddr is 24-bit count of previous records of types S1-S3
#  'S7'       = absaddr is 32-bit start execution address
#  'S8'       = absaddr is 24-bit start execution address
#  'S9'       = absaddr is 16-bit start execution address
# count      = #absaddr bytes + #data bytes + 1 (checksum byte)
# absaddr    = absolute address or record count
# data       = data bytes of absolute memory image (0-64 pairs)
# checksum   = one's complement of count bytes+absaddr bytes+data bytes

# file format is: S0-S[123]-S[56]-S[987]
# - only S[123] records can appear more than once in an output file

local function write_m_hex(type, addr, data) {

    local cnt
    local hex

    hexChkSum = 0

    # determine size of address field

    if ( type == 3 || type == 7 )
        cnt = 5
    else if ( type == 2 || type == 6 || type == 8 )
        cnt = 4
    else # type == 0 || type == 1 || type == 5 || type == 9
        cnt = 3

    hex = bytes2hexstr( num2msb(cnt-1, addr) )

    # data record ?

    if ( type > 0 && type < 4 ) {

        ++hexRecCount

        cnt += length( data )
        hex = hex bytes2hexstr( data )
    }

    # create line body; checksum is 1's complement

    hexout( sprintf("%d%02X%s", type, cnt, hex), not(hexChkSum+cnt) )
}

# verify a record type is unsupressed

local function rec_allowed(type) { return( !(type in outputOverride) ) }

# write Motorola header record

local function write_m_bof() {

    hexRecCount = 0

    if ( rec_allowed("noheader") )
        write_m_hex( 0, 0, 0 )
}

# write Motorola data record

local function write_m_data(addr, data) {

    write_m_hex( hexAddrType, addr, data )
}

# write Motorola data count and EOF records

local function write_m_eof(writestart) {

    local addr

    if ( hexRecCount && rec_allowed("nocount") )
        write_m_hex( hexRecCount < 0x10000 ? 5 : 6, hexRecCount )

    # may we use a start address ?
    # - do we have one ?

    addr = writestart && hexStartExpr ? hexStartAddr : 0

    write_m_hex( 10 - hexAddrType, addr )
}

# ----------------------------------------
# Dual Intel/Motorola functions
# ----------------------------------------

# handle "ASSUME" psop

global function CGdoassume(cmd, arg) {

    local bits, val

    bits = 0

    if ( cmd == "hexfile" ) {

        if ( arg == "segmented" )
            bits = 20
        else if ( arg == "linear" )
            bits = 32
        else
            UMignored( arg )
    }

    else if ( cmd == "srecfile" ) {

        if ( arg == "s19" )
            bits = 16
        else if ( arg == "s28" )
            bits = 24
        else if ( arg == "s37" )
            bits = 32
        else if ( arg ~ /^no(header|count)$/ )
            outputOverride[ arg ] = ".T."
        else
            UMignored( arg )
    }

    else if ( cmd == "hexdatasize" ) {

        val = EXPgetinrange( arg, 8, 32 )
        if ( CKok(val) && CKunique(val, cmd, outputOverride) )
            hexChunkSize = val
    }

    else if ( cmd ~ /^bit(08|16|24|32)r?$/ )
        CGbyteseq( cmd, arg )

    # not handled

    else {

        return( FALSE )
    }

    # re-set pc width ?

    if ( bits && CKunique(arg, cmd, outputOverride) )
        PCsetwidth( bits )

    # handled

    return( TRUE )
}

# output hex object code segment

local function put_hexseg(segnum, isintel) {

    local i, j
    local absaddr, hexndx
    local octet_cnt
    local elem_cnt, byte_cnt
    local dataseq, data, hex

    # addresses within a segment are continuous,
    # so if we know the first we can calculate any others we need

    absaddr = PCgetsegbeg( segnum )
    hexndx  = 0

    # set data octet count of an output line
    # - multiplication prevents a "byte" from being split across two lines
    # - max data octets = 32 * 4 = 128, max data chars = 32 * 4 * 2 = 256

    octet_cnt = hexChunkSize * byteSize

    dataseq = outputSeq[ segnum ]
    elem_cnt = length( dataseq )
    for ( i = 1; i <= elem_cnt; i++ ) {

        # collect/output data at this index

        data = datacode( dataseq[i] )
        byte_cnt = length( data )
        for ( j = 1; j <= byte_cnt; j++ ) {
            hex[ ++hexndx ] = data[ j ]

            # line length reached (full output line) ?

            if ( hexndx >= octet_cnt ) {
                if ( isintel )
                    write_i_data( absaddr, hex )
                else
                    write_m_data( absaddr, hex )
                absaddr += hexChunkSize
                hexndx = 0
                delete( hex )
            }
        }
    }

    # write any remaining partial line

    if ( hexndx ) {
        if ( isintel )
            write_i_data( absaddr, hex )
        else
            write_m_data( absaddr, hex )
    }
}

# ----------------------------------------
# All-format functions
# ----------------------------------------

# initialize for output

local function init_output(ftype) {

    # binary object ?

    if ( ftype == "OBJ" )
        return( init_b_output() )

    # Intel ?

    if ( ftype == "HEX" )
        return( init_i_output() )

    # Motorola

    # ftype == "SREC"

    return( init_m_output() )
}

# open output file and write beginning-of-file record (if any)
# - returns non-zero if file opened, else zero

local function put_bof(ftype, name) {

    outFile = CKfopen( name, ftype == "OBJ" ? "wb" : "wt" )

    if ( outFile ) {
        if ( ftype == "HEX" )
            write_i_bof()            
        else if ( ftype == "SREC" )
            write_m_bof()
    }

    return( outFile )
}

# write one segment

local function put_segment(ftype, segnum) {

    if ( ftype == "OBJ" )
        put_binseg( segnum )
    else if ( ftype == "HEX" )
        put_hexseg( segnum, TRUE )
    else # ftype == "SREC"
        put_hexseg( segnum, FALSE )
}

# write end-of-file record (if any) and close output file

local function put_eof(ftype, writestart) {

    if ( ftype == "HEX" )
        write_i_eof( writestart )
    else if ( ftype == "SREC" )
        write_m_eof( writestart )

    close( outFile )
}

# output a single object file containing all segments

local function putfile(ftype) {

    local segnum
    local segcnt
    local name, ext

    segcnt = make_output_seq()
    ext = init_output( ftype )
    name = CKgetfname( ftype "FILE", ext )

    if ( put_bof(ftype, name) ) {
        for ( segnum in outputSeq )
            put_segment( ftype, segnum )
        put_eof( ftype, TRUE )
    }
}

# output one object file for each segment

local function putbyseg(ftype) {

    local segnum
    local segcnt
    local name, ext

    segcnt = make_output_seq()
    ext = init_output( ftype )

    for ( segnum in outputSeq ) {
        --segcnt
        name = CKgetsegname( ftype "BYSEG", ext, segnum )
        if ( put_bof(ftype, name) ) {
            put_segment( ftype, segnum )
            put_eof( ftype, !segcnt )
        }
    }
}

# output one object file for each contiguous group of segments

local function putbyblock(ftype) {

    local segnum
    local segcnt
    local name, ext
    local newblock, nextseg

    segcnt = make_output_seq()
    ext = init_output( ftype )
    newblock = TRUE

    for ( segnum in outputSeq ) {
        --segcnt

        # begin a block of segments ?
        # - failure to open file will just re-try on next segment

        if ( newblock ) {
            name = CKgetsegname( ftype "BYBLOCK", ext, segnum )
            if ( !put_bof(ftype, name) )
                continue
        }

        put_segment( ftype, segnum )

        # is next segment part of current block ?

        nextseg = segnum + 1
        newblock = !(nextseg in outputSeq) \
            || ( PCgetsegend(segnum) != PCgetsegbeg(nextseg) )

        # end a block of segments ?

        if ( newblock )
            put_eof( ftype, !segcnt )
    }
}

# handle one type of single- and multi-file output

local function putobject(ftype)  {

    # single-file output
    # "OBJFILE", "HEXFILE", "SRECFILE"

    if ( CKoutput(ftype "FILE") )
        putfile( ftype )

    # multi-file output
    # "OBJBYSEG", "HEXBYSEG", "SRECBYSEG"
    # "OBJBYBLOCK", "HEXBYBLOCK", "SRECBYBLOCK"

    if ( PCsegmented() ) {
        if ( CKoutput(ftype "BYSEG") )
            putbyseg( ftype )
        if ( CKoutput(ftype "BYBLOCK") )
            putbyblock( ftype )
    }
}

# handle object file output

global function CGputobject() {

    if ( dataNdx ) {      
        putobject( "OBJ" )
        putobject( "HEX" )
        putobject( "SREC" )
    }
}
