<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>Hobby Cross Assembler v0.201</TITLE>
</HEAD>
<BODY>
<A NAME="top"></A>
<CENTER>
<H2>Hobby Cross Assembler v0.201</H2>
</CENTER>
<P><HR WIDTH=50%>
<P>
Copyright (C) 2004-2013 by Anton Treuenfels
<P>
<UL>
<LI><A HREF="#l3e">License and Terms</A>
<LI><A HREF="#l34">Introduction to HXA</A>
<LI><A HREF="#l02">Contact Information</A>
<LI><A HREF="#l85">Scope of This Document</A>
<LI><A HREF="#l84">Related Resources</A>
<LI><A HREF="#l33">HXA Features</A>
<LI><A HREF="#l3f">New in v0.201</A>
<LI><A HREF="#l01">"Hello, World!"</A>
<LI><A HREF="#l03">Executing HXA</A>
<LI><A HREF="#l86">Source Code Format</A>
<UL>
<LI><A HREF="#l89">Label and Opcode Fields</A>
<LI><A HREF="#l88">Expression Field</A>
<LI><A HREF="#l87">Comment Field</A>
</UL>
<LI><A HREF="#l35">Labels</A>
<UL>
<LI><A HREF="#l39">Names</A>
<LI><A HREF="#l3b">Types</A>
<LI><A HREF="#l3c">Values</A>
<LI><A HREF="#l37">Global</A>
<LI><A HREF="#l38">Local</A>
<LI><A HREF="#l3d">Variable</A>
<LI><A HREF="#l36">Branch Target</A>
<LI><A HREF="#l3a">Predefined</A>
</UL>
<LI><A HREF="#l04">Expressions</A>
<UL>
<LI><A HREF="#l07">Numeric Expressions</A>
<LI><A HREF="#l08">Octet Extraction Order</A>
<LI><A HREF="#l0a">Operands</A>
<LI><A HREF="#l2e">Operators</A>
<LI><A HREF="#l31">Unary Operators</A>
<LI><A HREF="#l06">Logical Short Circuit</A>
<LI><A HREF="#l30">Ternary Conditional</A>
<LI><A HREF="#l32">Undetected Errors</A>
<LI><A HREF="#l05">Caching</A>
</UL>
<LI><A HREF="#l49">Pseudo Opcodes</A>
<UL>
<LI><A HREF="#l4a">Alphabetic Ordering</A>
<LI><A HREF="#l4b">Functional Ordering</A>
<LI><A HREF="#l4c">Reference</A>
</UL>
<LI><A HREF="#l40">Non-Standard BYTE Sizes</A>
<UL>
<LI><A HREF="#l42">BIT-- Pseudo Ops</A>
<LI><A HREF="#l43">FILL Pseudo Op</A>
<LI><A HREF="#l44">HEX Pseudo Op</A>
<LI><A HREF="#l46">INCBIN Pseudo Op</A>
<LI><A HREF="#l47">PADTO Pseudo Op</A>
<LI><A HREF="#l48">STRING-- Pseudo Ops</A>
<LI><A HREF="#l41">Bit Extraction Operators</A>
<LI><A HREF="#l45">Hexadecimal Output Files</A>
</UL>
</UL>
<P>
<P><HR WIDTH=50%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l3e">License and Terms</A>
</BIG>
</STRONG>
</CENTER>
<P>
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
<P>
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
<P>
You should have received a copy of the
<A HREF="license.gpl">GNU General Public License</A>
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=50%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l34">Introduction to HXA</A>
</BIG>
</STRONG>
</CENTER>
<P>
HXA is a macro cross assembler created simply
for fun as a hobby project (hence the name).
HXA reflects many of my own ideas about what is and is not important
in assembler design.
<P>
Perhaps the most central idea from a programmer's viewpoint
is that HXA requires almost every programmer intention to be made
explicit in assembly source code.
I've had the experience of trying to read source code
in unfamiliar languages for assemblers whose manuals I did not have.
That's not so easy, so HXA tries to make sure both writer and reader
have no doubt about what is supposed to happen.
<P>
An area of ongoing concern is error detection and reporting.
HXA has been designed from the start to detect many possible
source code errors.
If found, errors are reported in a consistent manner that attempts
to make clear what, why and where something went wrong.
The aim is to give a progammer trying to fix an error a "fighting chance".
<P>
HXA makes an effort to accomodate programmers used to the conventions
of other assemblers.
It is fairly agnostic with regard to how numeric literals are specified
and what the exact names of pseudo ops are.
<P>
A couple of things I don't worry much about are size and speed.
Current machines are very fast and have very large memories, so
concerns of this nature in an assembler aren't too pressing.
While trying to never needlessly inflate HXA,
when push comes to shove I permit it to get larger and slower.
That said, the MS-DOS version of HXA typically assembles source code
at 400-500 lines per second on an old Pentium 166.
<P>
I hope you find using HXA to be both productive and enjoyable.
If you have any questions or comments, please let me know.
There are many excellent ideas still unstolen, and these will help decide
which ones are plundered next :)
<P>
- Anton Treuenfels
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=50%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l02">Contact Information</A>
</BIG>
</STRONG>
</CENTER>
<P>
Snail-mail:
<UL>
<LI>
Anton Treuenfels
<LI>
5248 Horizon Dr
<LI>
Fridley MN 55421
</UL>
<P>
E-mail:
<UL>
<LI>
<A HREF="mailto:hxa@earthlink.net">hxa@earthlink.net</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=50%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l85">Scope of This Document</A>
</BIG>
</STRONG>
</CENTER>
<P>
HXA is designed to be fairly portable between various processors.
This document describes only those portions of HXA which
are processor-independent.
<P>
As assemblers in general are largely concerned with textual
manipulation of assembly source code, this is actually most of HXA.
<P>
In the present version of HXA the only portions which "understand"
the processor instruction opcodes of
any particular assembly language are isolated in a single one of its
own source files.
Replacement of this file is one method of producing variants of HXA
capable of handling different assembly languages.
Each existing such variant is discussed in a separate document.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=50%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l84">Related Resources</A>
</BIG>
</STRONG>
</CENTER>
<P>
HXA
<UL>
<LI>
<A HREF="hxa_mesg.htm#l01">Assembler Message Texts</A>
 : error and status defaults
<LI>
<A HREF="hxa_test.htm#l01">General Tests</A>
 : basic functionality tests
(also basic coding examples)
<LI>
<A HREF="hxa_demo.htm#l01">General Demos</A>
 : intermediate coding examples
(also intermediate functionality tests)
<LI>
<A HREF="hxa_src.htm">Source Code</A>
 : overviews of version history, source language,
overall design and modification to accept other assembly languages
</UL>
<P>
HXA Variants
<UL>
<LI>
<A HREF="hxa_t.htm">T_XX Family</A>
 : imaginary test processors
<LI>
<A HREF="hxa65.htm">6502 Family</A>
 : 6502, 65C02, R65C02, W65C02S, W65C816S
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=50%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l33">HXA Features</A>
</BIG>
</STRONG>
</CENTER>
<P>
Labels
<UL>
<LI>
<EM>numeric</EM>
 and 
<EM>string</EM>
 types
<LI>
<A HREF="#l37">global</A>
, 
<A HREF="#l38">local</A>
, 
<A HREF="#l3d">variable</A>
 and 
<A HREF="#l36">branch target</A>
 sub-types
</UL>
<P>
Expressions
<UL>
<LI>
32-bit algebraic 
<A HREF="#l04">expression evaluation</A>
including nested sets of parentheses
<LI>
operands include labels, 
<A HREF="#l26">numbers</A>
, 
<A HREF="#l2c">program counter</A>
,
<A HREF="#l24">characters</A>
, 
<A HREF="#l28">strings</A>
 and 
<A HREF="#l27">regular expressions</A>
<LI>
decimal, hexadecimal and binary numbers
in both Motorola and Intel formats recognized
<LI>
characters and strings can include 
<A HREF="#l25">escape sequences</A>
<LI>
<A HREF="#l2e">operators</A>
 include arithmetic, logical, string
and regular expression pattern matching
<LI>
logical, numeric and string 
<A HREF="#l0b">functions</A>
</UL>
<P>
Pseudo Opcodes
<UL>
<LI>
<A HREF="#l54">BIT--</A>
, 
<A HREF="#l74">RBIT--</A>
, 
<A HREF="#l78">SBIT--</A>
 and 
<A HREF="#l7d">UBIT--</A>
 numeric data storage
pseudo ops allow selection of number of bytes,
byte order and range-checking of values stored
<LI>
<A HREF="#l68">MACRO..ENDMACRO</A>
, 
<A HREF="#l77">REPEAT..ENDREPEAT</A>
 and 
<A HREF="#l82">WHILE..ENDWHILE</A>
 blocks
with automatic local label scoping and no fixed limit on nesting depth
<LI>
<A HREF="#l63">IF..ELSEIF..ELSE..ENDIF</A>
 conditional assembly blocks
with no fixed limit on nesting depth
<LI>
<A HREF="#l65">INCLUDE</A>
 multiple source files with no fixed limit on nesting depth
<LI>
customize HXA by redefining 
<A HREF="#l83">character set translation</A>
,
status and error 
<A HREF="#l6b">message texts</A>
,
and 
<A HREF="#l70">pseudo opcode names</A>
<LI>
supports monolithic and 
<A HREF="#l79">segmented</A>
 programming styles
<LI>
and 
<A HREF="#l4a">many others...</A>
</UL>
<P>
File Output
<UL>
<LI>
absolute raw binary, Intel hexadecimal and Motorola SRecord format
<A HREF="#l50">object files</A>
<LI>
object output in one piece, by 
<A HREF="#l4e">segments</A>
or by 
<A HREF="#l4d">blocks</A>
<LI>
listing (w/ optional cross-referencing) and error files
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=50%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l3f">New in v0.201</A>
</BIG>
</STRONG>
</CENTER>
<P>
<EM>All Versions</EM>
<P>
Extended
<UL>
<LI>
all error messages now indicate how HXA treated the source line, eg.,
as a mnemonic, pseudo opcode, macro invocation, etc.
<LI>
in cases of duplicate name errors HXA now differentiates between
conflicts with built-in names and those with user-defined names
</UL>
<P>
A complete list of 
<A HREF="hxa_src.htm#l33">all changes in v0.201</A>
 can be found in the
implementation documentation.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=50%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l01">"Hello, World!"</A>
</BIG>
</STRONG>
</CENTER>
<P>
The short "Hello, World!" program is the first example on
the first page of "The C Programming Language" by Kernighan and Ritchie.
First published in 1978, it has since become a very popular example for
introducing almost any programming language.
<P>
While HXA is not a programming language 
<EM>per se</EM>
, the assembly languages it
supports are.
The 
<A HREF="hxa_helo.htm">"Hello, World!" Demos</A>
 provide short examples of how
HXA may be used to create real programs for real computers.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=50%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l03">Executing HXA</A>
</BIG>
</STRONG>
</CENTER>
<P>
All variants of HXA accept a single filename as a command-line argument:
<P>
<CODE>
<STRONG>HXAxx</STRONG>
<EM>filename</EM>
</CODE>
<P>
<EM>HXAxx</EM>
 is the specific variant of HXA invoked, where "
<EM>xx</EM>
"
is replaced by a variant identifier.
<P>
<EM>Filename</EM>
 is assumed to be a text file containing
assembly language source code.
<P>
If multiple source files are to be assembled together, they must
be specified within the root 
<EM>filename</EM>
 by using the
<A HREF="#l65">"INCLUDE"</A>
 pseudo opcode.
<P>
<EM>Filename</EM>
 may contain device and/or directory specifiers (ie., a 
<EM>path</EM>
).
If 
<EM>filename</EM>
 contains a path, HXA automatically prefixes every
other input and output file named within 
<EM>filename</EM>
 with that same path.
The only exception is if a named file has its own path containing
a device identifier or starts from the root directory, in which case
HXA uses that path instead.
<P>
The effect is that files named within 
<EM>filename</EM>
 can normally be specified
by their location relative to it, but if desired an absolute location
can be specified instead.
<P>
There are no command-line options or flags.
Changes to HXA's default behavior are made explicit by 
<A HREF="#l49">pseudo opcodes</A>
used within the source file(s).
<P>
By default HXA produces no output other than status and error messages.
These are sent to 
<EM>stdout</EM>
, which is normally the screen (console).
If no screen output is desired, 
<EM>stdout</EM>
 may be re-directed on the command
line to a file (to capture all such output) or the null (NUL) device
(to ignore all such output).
<P>
Several 
<A HREF="#l50">"--FILE"</A>
 pseudo ops can direct HXA to produce error,
raw binary, Intel hex, Motorola hex and/or listing files as desired.
<P>
At exit HXA returns a value of zero if no warnings or errors were
encountered during assembly.
An exit value of one to seven is bit-mapped to report the type of
problem(s) encountered:
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<TR ALIGN=CENTER>
<TD>
Bit Value
<TD>
Detected
<TR ALIGN=CENTER>
<TD>
$01
<TD>
Warning(s)
<TR ALIGN=CENTER>
<TD>
$02
<TD>
Error(s)
<TR ALIGN=CENTER>
<TD>
$04
<TD>
Fatal Error
</TABLE>
<P>
A value of two or higher implies HXA halted assembly and produced only
an error file (if one was specified).
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=50%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l86">Source Code Format</A>
</BIG>
</STRONG>
</CENTER>
<P>
HXA accepts standard ASCII text files as source code.
Each line of a text file is treated as a separate source code line.
<P>
A source code line may consist of up to four logical fields:
<P>
<A HREF="#l35">LABEL</A>
 OPCODE 
<A HREF="#l04">EXPRESSION</A>
<A HREF="#l87">COMMENT</A>
<P>
These fields are separated from each other by one or more whitespace
characters.
Each field is optional, but if present must appear in the order shown.
The only restriction is that expressions must follow an opcode;
they cannot appear alone or directly following a label.
<P>
Malformed source lines are an error.
<P>
Note that the actual column position of any field within a source code
line is not important to HXA.
<EM>What</EM>
 a field represents is more important than 
<EM>where</EM>
 it is.
<P>
Examples
<UL>
<LI>
LABEL
<LI>
LABEL OPCODE
<LI>
LABEL OPCODE EXPRESSION
<LI>
LABEL COMMENT
<LI>
OPCODE
<LI>
OPCODE EXPRESSION
<LI>
OPCODE COMMENT
<LI>
COMMENT
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l89">Label and Opcode Fields</A>
</BIG>
</STRONG>
</CENTER>
<P>
HXA is case-insensitive with respect to 
<A HREF="#l35">labels</A>
 and opcodes:
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>All The Same To HXA</CAPTION>
<TR ALIGN=CENTER>
<TD>
<STRONG>User Label</STRONG>
<TD>
<STRONG>Pseudo Opcode</STRONG>
<TR ALIGN=CENTER>
<TD>
MYLABEL
<TD>
BYTE
<TR ALIGN=CENTER>
<TD>
mylabel
<TD>
byte
<TR ALIGN=CENTER>
<TD>
MyLabel
<TD>
Byte
</TABLE>
<P>
Note that the opcode field may contain processor instruction opcodes,
assembler 
<A HREF="#l49">pseudo opcodes</A>
 or 
<A HREF="#l68">macro names</A>
.
As used here, 
<EM>opcode</EM>
 refers to all these types.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l88">Expression Field</A>
</BIG>
</STRONG>
</CENTER>
<P>
The expression field is separated from its preceeding opcode
by whitespace, and continues until the end of the source line or
the start of the comment field, whichever comes first.
Whitespace may be used in the expression field as desired.
<P>
HXA normally divides the expression field into sub-fields
before further processing.
Each comma (',') in the expression field marks the start of
a separate argument to the opcode it follows.
Leading and trailing whitespace is discarded from each sub-field.
Blank or empty sub-fields are not allowed.
<P>
There are exceptions where a comma does not divide:
<UL>
<LI>
it is 
<A HREF="#l25">escaped</A>
<LI>
it separates function arguments
<LI>
it appears in a 
<A HREF="#l24">character</A>
, 
<A HREF="#l28">string</A>
or 
<A HREF="#l27">regular expression</A>
 literal value
</UL>
<P>
The escape mechanism is the most general method of preventing
the expression field from being divided.
Commas in literal values and those separating
function arguments can also be escaped, if desired
(although there is no practical advantage in doing so).
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l87">Comment Field</A>
</BIG>
</STRONG>
</CENTER>
<P>
Source lines which have an asterisk ('*') in the first column,
or whose first non-whitespace character is a semi-colon (';'),
are considered comment lines, and are ignored.
<P>
A comment following a label, opcode or expression is indicated by
a semi-colon immediately preceeded by at least one whitespace character.
Note that if this sequence appears in a
<A HREF="#l28">string</A>
 or 
<A HREF="#l27">regular expression</A>
literal, the semi-colon must be
<A HREF="#l25">escaped</A>
in order to be handled properly.
<P>
Examples
<UL>
<LI>
* this entire line is ignored because of the '*' character in the
first column
<LI>
; this entire line is also ignored because of the leading ';' character
<LI>
myLabel: ; the first ';' character marks the start of the comment
<LI>
opcode "mySemicolon; my Semicolon" ; the second ';' follows a space
and marks the start of the comment
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=50%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l35">Labels</A>
</BIG>
</STRONG>
</CENTER>
<P>
In assembly languages labels are symbolic names used to represent values.
The symbolic names can then be used in expressions in place of those values.
<P>
Using symbolic names for values has at least three great advantages over
using the values directly.
First, a well-chosen name is much easier to remember than an obscure value.
Second, the same value may mean different things in different contexts, and
giving the same value a different name for each different context helps
keep each use of it clear.
Third, if the value associated with a name is ever changed it is guaranteed
that every use of that name is "automatically" updated, but avoids changing
the use of any other name that happens to have the same value.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l39">Names</A>
</BIG>
</STRONG>
</CENTER>
<P>
The basic form of named HXA labels starts with an alphabetic or
underscore character ('A-Z' or '_') followed by zero or more
alphanumeric or underscore characters ('A-Z0-9' or '_').
<P>
Period ('.') characters may also be used in a named label, but only
between two non-period characters.
Periods cannot be the first or last character of a named
label, nor can there be two consecutive period characters.
<P>
A final colon (':') suffix is optional for label names.
This is generally ignored by HXA, so '
<STRONG>MyLabel:</STRONG>
' and '
<STRONG>MyLabel</STRONG>
'
can be used interchangeably to represent the same value in
both label and expression fields.
<P>
Note however a colon suffix on the first field of a source code line
forces HXA to recognize the field as a label.
This can be used to distinguish a new label name from an existing
macro name.
<P>
Colons on label names can also help distinguish them from other
sorts of character groupings in search and replace operations while
editing source code.
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Valid Label Names</CAPTION>
<TR ALIGN=CENTER>
<TD>
myLabel
<TD>
_mylabel
<TD>
my.label
<TD>
mylabel:
<TR ALIGN=CENTER>
<TD>
wname
<TD>
__XName__
<TD>
y.n.a.m.e
<TD>
Z_Name:
<TR ALIGN=CENTER>
<TD>
target1
<TD>
target_2
<TD>
t.123
<TD>
trgt.3:
</TABLE>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l3b">Types</A>
</BIG>
</STRONG>
</CENTER>
<P>
HXA allows labels to represent 
<EM>numeric</EM>
 and 
<EM>string</EM>
 values.
The type of a label is made manifest by the presence or absence of a
dollar sign suffix ('$'): a label without this suffix represents a
numeric value, a label with it a string.
If a string label also has a colon suffix, the dollar sign preceeds the
colon (ie., any colon is always the last character of any named label).
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Label Types</CAPTION>
<TR ALIGN=CENTER>
<TD>
<STRONG>Numeric</STRONG>
<TD>
<STRONG>String</STRONG>
<TR ALIGN=CENTER>
<TD>
myNumLabel
<TD>
myStrLabel$
<TR ALIGN=CENTER>
<TD>
temp1
<TD>
t2$
<TR ALIGN=CENTER>
<TD>
colonNum:
<TD>
colonStr$:
</TABLE>
<P>
HXA extends its manifest typing system to distinguish several sub-types
of numeric and string labels.
The sub-type of a label is distinguished by the first character of its name.
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>HXA Label Sub-Types</CAPTION>
<TR ALIGN=CENTER>
<TD>
<STRONG>Sub-Type</STRONG>
<TD>
<STRONG>Indicator</STRONG>
<TD>
<STRONG>Initial Character</STRONG>
<TD>
<STRONG>Ex: Numeric</STRONG>
<TD>
<STRONG>Ex: String</STRONG>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l35">Global</A>
<TD>
Alphabetic or underscore
<TD>
'_A-Z'
<TD>
myGlobal
<TD>
aGlobal$
<TR ALIGN=CENTER>
<TD>
<A HREF="#l35">Local</A>
<TD>
"At" sign
<TD>
'@'
<TD>
@myLocal
<TD>
@aLocal$
<TR ALIGN=CENTER>
<TD>
<A HREF="#l35">Variable</A>
<TD>
Right bracket
<TD>
']'
<TD>
]myVar
<TD>
]aVar$
<TR ALIGN=CENTER>
<TD>
<A HREF="#l36">Branch Target</A>
<TD>
Plus | Minus | Colon
<TD>
'[+-:]'
<TD>
+
<TD>
n/a
</TABLE>
<P>
Notes:
<UL>
<LI>
branch target (aka 
<EM>anonymous</EM>
 or 
<EM>unnamed</EM>
) labels are always numeric
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l3c">Values</A>
</BIG>
</STRONG>
</CENTER>
<P>
Labels appearing in the label field of a source code line
are assigned values.
Most often the value is the current value of the program counter.
HXA makes this assignment automatically; in most cases a programmer
doesn't know (or need to know) what the actual value of such a label is.
<P>
For numeric labels this value is an integer
which can be used directly as a memory address.
For string labels this value takes the form of a decimal string
representation of the same memory address.
<P>
Both types of labels can also be assigned explicit values with
the 
<A HREF="#l5b">"EQU"</A>
 pseudo opcode.
For string labels this is the most common method.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l12">All Label Forms</A>
<LI>
<A HREF="hxa_test.htm#l23">String Labels</A>
<LI>
<A HREF="hxa_test.htm#l13">Assign Label Value</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l37">Global</A>
</BIG>
</STRONG>
</CENTER>
<P>
Global labels, as their name implies, have global scope.
The value represented by a global label can be accessed from
anywhere in the source code file(s).
<P>
Global labels are fixed.
Once assigned a value, that value cannot be changed.
However the same value may be assigned to the same global label
any number of times.
<P>
Global label names must be unique.
No two global labels can have the same name.
<P>
A global label in the label field of a source code line
causes the current local scope to terminate.
All current 
<A HREF="#l35">local</A>
 label names and values are forgotten,
and a new local scope begins.
<P>
In general global label names which match processor instruction opcodes,
assembler 
<A HREF="#l49">pseudo opcodes</A>
, or previously defined
<A HREF="#l68">macro names</A>
 should be avoided.
Global labels in the first field of source code line which match any of
these 
<EM>will not</EM>
 be recognized correctly (however a global name with a
colon suffix will not match any existing name except another global name).
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l17">Global Labels</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l38">Local</A>
</BIG>
</STRONG>
</CENTER>
<P>
Local labels, as their name implies, have local scope.
The value represented by a particular local label cannot be accessed
outside the scope it is created in.
Expressions within one local scope cannot successfully "reach out"
of it to use the value of a local label in another scope.
<P>
Local labels are fixed.
Once assigned a value, that value cannot be changed.
However the same value may be assigned to the same local label
in the same local scope any number of times.
<P>
Local label names within the same local scope must be unique.
Local labels in different local scopes may have the same name.
<P>
In HXA local scoping is for the most part managed automatically based on
block concepts:
entering a block creates a new local scope and exiting a block ends it.
Since blocks can be nested, so can local scopes.
<P>
A file is a block, thus the first local scope is the same as the
first source file.
<A HREF="#l65">File inclusion</A>
 causes HXA to automatically create a nested
local scope for each file included.
<P>
Any given level of nested scope is further subdivided by global labels.
Used in the label field, a global label ends the current local scope and
opens a new one at the same level.
<P>
If there is only one block in a source file,
then the value of any particular local label can be accessed
only between the two global labels it is surrounded by (or, at the extremes,
between a global label and the start or end of the file).
If such a source file had no global labels, any local label in it
would have to be unique.
<P>
Nested local scopes are also created by the expansion of
<A HREF="#l68">macro</A>
, 
<A HREF="#l77">repeat</A>
and 
<A HREF="#l82">while</A>
 blocks.
<P>
In 
<A HREF="#l79">segmented</A>
 source files, each use of a segment
fragment creates a nested local scope while that fragment is active.
<P>
All these scopes follow the same rules as the original file-level local scope.
That is, they can be subdivided by global labels and any local labels in
a subdivision must be unique.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l18">Local Labels</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l3d">Variable</A>
</BIG>
</STRONG>
</CENTER>
<P>
Variable labels have global scope.
The current value represented by one of these labels
can be accessed from anywhere in the source code file(s).
<P>
Variable labels, as their name implies, are not fixed.
The value represented by one of these labels can be changed at any time
by using it in the label field of any source code line which allows labels.
<P>
Variable label names are by default unique.
Any use of a particular variable label name is considered to refer
to the same variable label.
<P>
References to variable labels normally represent the value they were
most recently assigned.
Thus variable labels in expression should usually be used only for
<EM>backward</EM>
 references.
That is, they should appear in a label field 
<EM>before</EM>
they are used in an expression field, so that they have a known value.
<P>
HXA does permit 
<A HREF="#l2a">forward reference</A>
 to variable labels, but this useage is
obscure and difficult to use successfully.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l27">Variable Labels</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l36">Branch Target</A>
</BIG>
</STRONG>
</CENTER>
<P>
Branch target labels (also called 
<EM>anonymous</EM>
 or 
<EM>unnamed</EM>
 labels)
have global scope.
The value represented by one of these labels
can be accessed from anywhere in the source code file(s).
<P>
Branch target labels are fixed.
Once assigned, their values cannot be changed.
<P>
Branch target label names are 
<EM>not</EM>
 unique.
There are only three names: plus sign ('+'), minus sign ('-')
and colon (':').
<P>
A plus sign marks its location as a 
<EM>forward</EM>
 target, a minus sign as a
<EM>backward</EM>
 target, and a colon as both a 
<EM>forward and backward</EM>
 target.
The plus and minus signs may also be used together ('+-' or '-+')
to mark a location as both a 
<EM>forward and backward</EM>
 target.
<P>
To mark a source code line as a branch target, use a branch target
name in the label field.
There are no restrictions on how often any of the three names may be used.
Each time a branch target label is found in the label field,
HXA associates it with a unique internal name.
<P>
The terms 
<EM>forward</EM>
 and 
<EM>backward</EM>
 in this context mean where in the
source code these names appear in relation to references to them in
the expression fields of other source code lines.
If a name appears in a label field before a reference to it in an
expression field, the reference is 
<EM>backward</EM>
 and the name must be either
minus sign or colon.
If a name appears in a label field after a reference to it in an
expression field, the reference is 
<EM>forward</EM>
 and the name must be either
plus sign or colon.
<P>
As there name implies, branch target labels are meant to serve as
the destination points of program control branches.
Branch target labels relieve the programmer of the burden of creating
a unique label name for what is frequently a one-time-only use.
<P>
Branch target labels most often appear on a source code line either
by themselves or together with a processor instruction mnemonic.
Thus the value of the name is usually the current value of the
program counter.
<P>
HXA actually permits branch target labels to be used with any
<A HREF="#l49">pseudo opcodes</A>
 which accept labels,
but this useage is unusual and generates a warning.
If a branch target label really is meant to refer to the location of a
pseudo opcode, the warning can be avoided by placing
the label on a line by itself and the pseudo opcode on the next
following line.
<P>
Note that colons (or plus-minus pairs) can be used for all
branch target labels if desired.
There is no penalty for not using a forward/backward target label in both
directions.
More generally, there is no penalty for not using any named or unnamed
label in any expression at all.
<P>
In the expression field references to branch targets are considered
references to 
<A HREF="#l2b">numeric labels</A>
.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l14">Branch Target Labels</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l3a">Predefined</A>
</BIG>
</STRONG>
</CENTER>
<P>
All versions of HXA define at least one label:
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<TR ALIGN=CENTER>
<TD>
<STRONG>Name</STRONG>
<TD>
<STRONG>Value</STRONG>
<TR ALIGN=CENTER>
<TD>
__HXA__
<TD>
TRUE
</TABLE>
<P>
This label is intended mainly for use in 
<A HREF="#l62">"IFDEF"</A>
conditional blocks, but may be used in any legal context.
<P>
Processor-specific versions of HXA may also define additional predefined
labels.
These can be used for identifying the supported processor or processor family
or to prevent register names from being used as labels.
<P>
All predefined labels have a value of TRUE and are available for use
as soon as HXA begins reading source code.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=50%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l04">Expressions</A>
</BIG>
</STRONG>
</CENTER>
<P>
<UL>
<LI><A HREF="#l07">Numeric Expressions</A>
<LI><A HREF="#l08">Octet Extraction Order</A>
<LI><A HREF="#l0a">Operands</A>
<LI><A HREF="#l2e">Operators</A>
<LI><A HREF="#l31">Unary Operators</A>
<LI><A HREF="#l06">Logical Short Circuit</A>
<LI><A HREF="#l30">Ternary Conditional</A>
<LI><A HREF="#l32">Undetected Errors</A>
<LI><A HREF="#l05">Caching</A>
</UL>
<P>
HXA supports both 
<EM>numeric</EM>
 and 
<EM>string</EM>
 expressions.
Legal expressions consist of at least one operand and zero or more
<A HREF="#l04">operators</A>
.
Operands and operators may be separated by spaces for clarity.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l07">Numeric Expressions</A>
</BIG>
</STRONG>
</CENTER>
<P>
HXA performs numeric expression evaluation with a final result in the
range of a 32-bit integer, signed or unsigned.
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Numeric Range</CAPTION>
<TR ALIGN=CENTER>
<TD>
-
<TD>
<STRONG>Binary</STRONG>
<TD>
<STRONG>Decimal</STRONG>
<TD>
<STRONG>Hexadecimal</STRONG>
<TR ALIGN=CENTER>
<TD>
<STRONG>Signed Minimum</STRONG>
<TD>
%100000000000000000000000000000000
<TD>
-2147483648
<TD>
$80000000
<TR ALIGN=CENTER>
<TD>
<STRONG>Unsigned Minimum</STRONG>
<TD>
%000000000000000000000000000000000
<TD>
0
<TD>
$00000000
<TR ALIGN=CENTER>
<TD>
<STRONG>Signed Maximum</STRONG>
<TD>
%011111111111111111111111111111111
<TD>
2147483647
<TD>
$7FFFFFFF
<TR ALIGN=CENTER>
<TD>
<STRONG>Unsigned Maximum</STRONG>
<TD>
%111111111111111111111111111111111
<TD>
4294967295
<TD>
$FFFFFFFF
</TABLE>
<P>
It may be observed that the normal count of values that can be represented
by 32 bits is 2^32, and that the range from signed minimum to unsigned
maximum is half again as large.
It is the underlying run-time package used by HXA which permits this.
Values outside the range of a signed integer are maintained as signed
double precision floating point.
When necessary HXA renders these in the bit patterns appropriate for
32-bit unsigned integers.
<P>
Note that use of double precision floats means intermediate overflow of
32 bits in calculations does 
<EM>not</EM>
 result in "wrapping" of values from
positive to negative or vice-versa.
That is, arithmetic is 
<EM>not</EM>
 modular.
This facility should be used carefully or not at all.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l08">Octet Extraction Order</A>
</BIG>
</STRONG>
</CENTER>
<P>
During file output HXA extracts all or part of 32-bit numeric values based
on the 
<A HREF="#l54">-BIT--</A>
 pseudo ops associated with them.
<P>
If the four 8-bit octets of a 32-bit value are labeled "3-2-1-0" from most
to least significant, then the default extraction sequences are:
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Octets Appear in Output in the Order</CAPTION>
<TR ALIGN=CENTER>
<TD>
-
<TD>
<STRONG>LSB Processor</STRONG>
<TD>
<STRONG>MSB Processor</STRONG>
<TR ALIGN=CENTER>
<TD>
-BIT08--
<TD>
0
<TD>
0
<TR ALIGN=CENTER>
<TD>
-BIT16--
<TD>
0-1
<TD>
1-0
<TR ALIGN=CENTER>
<TD>
-BIT24--
<TD>
0-1-2
<TD>
2-1-0
<TR ALIGN=CENTER>
<TD>
-BIT32--
<TD>
0-1-2-3
<TD>
3-2-1-0
</TABLE>
<P>
Custom extraction orders can be specified using the 
<A HREF="#l53">"ASSUME"</A>
psedo op.
Specify the base -BIT-- or -BIT--R family name and the desired order:
<P>
Examples
<UL>
<LI>
ASSUME BIT16R=01
<LI>
ASSUME BIT32=1032
<LI>
<A HREF="hxa_test.htm#l0b">ASSUME Non-Default Order</A>
</UL>
<P>
Notes
<UL>
<LI>
all related BIT--, RBIT--, SBIT-- and UBIT-- pseudo ops are affected
<LI>
a limited number of validity checks are made:
<LI>
the number of argument octets must match the number in the family
affected, eg., "BIT32" requires four octet numbers, "BIT08" just one
<LI>
argument octet numbers themselves must all be from the set 0..3
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l09">String Expressions</A>
</BIG>
</STRONG>
</CENTER>
<P>
String expressions yield string results (note that many operators on
string operands have numeric results).
The only string operation is 
<EM>concatenation</EM>
, which joins two strings
together to form a longer one.
HXA has no explicit concatenation operator; concatenation is implied
by placing two string operands adjacent to each other.
<P>
The results of string expressions may be up to at least 8000 characters
in length.
The underlying run-time package used by HXA may permit longer strings,
but this is not guaranteed in all versions of HXA.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l0a">Operands</A>
</BIG>
</STRONG>
</CENTER>
<P>
There are three basic kinds of operands: literals,
<A HREF="#l29">symbols</A>
 and 
<A HREF="#l0a">functions</A>
.
Each operand kind comes in two or more types.
<P>
<UL>
<LI><A HREF="#l23">Literals</A>
<LI><A HREF="#l29">Symbols</A>
<LI><A HREF="#l0b">Functions</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l23">Literals</A>
</BIG>
</STRONG>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l26">Numbers</A>
</BIG>
</STRONG>
</CENTER>
<P>
HXA recognizes binary, decimal and hexadecimal numeric literals
in Motorola, Intel and C/C++ formats.
For hexadecimals, the numbers 10 to 15 are represented by
the characters 'A-F' or 'a-f' (case doesn't matter).
<P>
In general, the base chosen to express a numeric literal should
make its intended use as clear as possible.
Leading zeros are always ignored, so they may be used freely to
help clarify the use intended.
<P>
Numeric literals are always interpreted as unsigned integers.
Negative values are obtained by applying the unary negate operator ('-').
<P>
Integer numeric literals may be used wherever a numeric value is expected.
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Example: The Number One Hundred Ninety-two</CAPTION>
<TR ALIGN=CENTER>
<TD>
-
<TD>
<STRONG>Binary</STRONG>
<TD>
<STRONG>Decimal</STRONG>
<TD>
<STRONG>Hexadecimal</STRONG>
<TR ALIGN=CENTER>
<TD>
<STRONG>Motorola</STRONG>
<TD>
%11000000
<TD>
192
<TD>
$C0
<TR ALIGN=CENTER>
<TD>
<STRONG>Intel</STRONG>
<TD>
11000000B
<TD>
192D
<TD>
0C0H
<TR ALIGN=CENTER>
<TD>
<STRONG>C/C++</STRONG>
<TD>
0b11000000
<TD>
192
<TD>
0xC0
</TABLE>
<P>
Intel-format number notes:
<UL>
<LI>
must always begin with a decimal digit character
(in particular, hexadecimal numbers; use '0' if necessary)
<LI>
the case of the base suffix is ignored (eg., 'h' and 'H' are equivalent)
<LI>
the 'D' suffix is optional for decimal numbers
</UL>
<P>
C/C++ format number notes:
<UL>
<LI>
while the '0b' prefix to specify a binary number is increasingly accepted,
it is not actually part of the official standard
</UL>
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l1c">Numeric Literals</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l24">Characters</A>
</BIG>
</STRONG>
</CENTER>
<P>
A character literal is a single character code delimited by
single quote marks ("'").
A single quote mark may itself be included in a character literal by
<A HREF="#l25">escaping</A>
it.
<P>
A character code may be specified by either its
printable ASCII representation or an
<A HREF="#l25">escape sequence</A>
.
The numeric value of a printable character is normally its position in the
ASCII collating sequence.
If the value of a character code according to the current
<A HREF="#l83">character set translation</A>
is desired instead, it can be obtained using the
<A HREF="#l0b">XLATE()</A>
 function.
<P>
Character literals may be used wherever a numeric value is expected.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l15">Character Literals</A>
<LI>
<A HREF="hxa_test.htm#l28">XLATE() and XLATE</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l28">Strings</A>
</BIG>
</STRONG>
</CENTER>
<P>
A string literal is a sequence of zero or more character codes
delimited by double quote marks ('"').
A double quote mark may itself be included in a literal string by
<A HREF="#l25">escaping</A>
it.
<P>
Each character code may be specified by either its
printable ASCII representation or an
<A HREF="#l25">escape sequence</A>
.
The numeric value of each printable character is normally its position in the
ASCII collating sequence.
<P>
String literals may be used wherever a string value is expected.
Note that when used with string comparison and pattern matching operators,
string literals are 
<EM>not</EM>
 affected by the current
<A HREF="#l83">character set translation</A>
.
<P>
String literals may also be used in some circumstances where a numeric
value is expected.
In such cases a string is converted to a numeric value by an implied
comparison against the null string before any numeric operator is applied.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l24">String Literals</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l27">Regular Expressions</A>
</BIG>
</STRONG>
</CENTER>
<P>
A regular expression pattern literal is a sequence of one or more
character codes delimited by forward slash ('/') characters.
A forward slash may itself be included in a regular expression by
<A HREF="#l25">escaping</A>
it.
<P>
Only pattern match operators apply to regular expressions.
Any
<A HREF="#l25">escape sequences</A>
in a regular expression are evaluated before a pattern match is attempted.
<P>
Regular expression patterns provide a compact and flexible way to
specify multiple partial or exact matches to a string.
They are provided by HXA mainly as an aid to
<A HREF="#l68">macro</A>
 creation.
<P>
A full tutorial in the use of regular expression patterns is beyond the
scope of this document.
Briefly, a regular expression pattern consists of 
<EM>normal</EM>
 characters,
which match those characters, and 
<EM>meta-characters</EM>
, which match
character types, groups or positions.
Most of the power of regular expressions is provided by meta-characters
singly or in combination with others.
<P>
For a fuller explanation, consult any AWK/GAWK/NAWK reference.
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Partial List of Recognized Meta-Characters</CAPTION>
<TR ALIGN=CENTER>
<TD>
<STRONG>To match</STRONG>
<TD>
<STRONG>Notation</STRONG>
<TD>
<STRONG>"abc" Matches</STRONG>
<TD>
<STRONG>"abc" does NOT Match</STRONG>
<TR ALIGN=CENTER>
<TD>
Any single character
<TD>
'.'
<TD>
/a.c/
<TD>
/xy./
<TR ALIGN=CENTER>
<TD>
Any character in a set
<TD>
[(set)]
<TD>
/[cde]/
<TD>
/[xyz]/
<TR ALIGN=CENTER>
<TD>
Any character not in a set
<TD>
[^(set)]
<TD>
/[^ghe]/
<TD>
/[^abc]/
<TR ALIGN=CENTER>
<TD>
Zero or more occurances of regular expression
<TD>
'*'
<TD>
/ax*/
<TD>
/axy*/
<TR ALIGN=CENTER>
<TD>
One or more occurances of regular expression
<TD>
'+'
<TD>
/ab+/
<TD>
/ax+/
<TR ALIGN=CENTER>
<TD>
Zero or one occurance of regular expression
<TD>
'?'
<TD>
/abcd?/
<TD>
/abcd?e/
<TR ALIGN=CENTER>
<TD>
At start of string
<TD>
'^'
<TD>
/^abc/
<TD>
/^abcd/
<TR ALIGN=CENTER>
<TD>
At end of string
<TD>
'$'
<TD>
/abc$/
<TD>
/ebc$/
<TR ALIGN=CENTER>
<TD>
Either of two regular expressions
<TD>
'|'
<TD>
/abc|def/
<TD>
/def|wxyz/
</TABLE>
<P>
Notes
<UL>
<LI>
appending an 'i' character to the pattern makes the regular expression
case-insensitive with respect to alphabetic characters.
The pattern /^abc$/i is equivalent to the pattern /^[aA][bB][cC]$/ and
matches the strings "abc", "Abc", "ABC", etc.
<LI>
HXA "recognizes" regular expressions by the delimiting slash marks and
passes them to the underlying run-time package for conversion into a form
suitable for fast pattern matching.
If there is an error in the composition of the regular expression the
run-time package will report an error that is not detected by HXA
</UL>
<P>
Regular expression literals may be used wherever a regular expression
is expected.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l16">Expression Evaluation</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l25">Escape Sequences</A>
</BIG>
</STRONG>
</CENTER>
<P>
Escape sequences can be used in character constants, string literals
and regular expression patterns to represent character codes that
are difficult to specify otherwise (eg., control codes).
There are two types of escape sequences, 
<EM>mnemonic</EM>
 and 
<EM>hexadecimal</EM>
.
<P>
<STRONG>Mnemonic Escape Sequences</STRONG>
<P>
Mnemonic escapes take the form of a backslash ('\') followed by
a printable character.
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Mnemonic Escape Sequences</CAPTION>
<TR ALIGN=CENTER>
<TD>
<STRONG>Character</STRONG>
<TD>
<STRONG>Name</STRONG>
<TD>
<STRONG>Sequence</STRONG>
<TR ALIGN=CENTER>
<TD>
0
<TD>
null
<TD>
\0
<TR ALIGN=CENTER>
<TD>
BS
<TD>
backspace
<TD>
\b
<TR ALIGN=CENTER>
<TD>
FF
<TD>
formfeed
<TD>
\f
<TR ALIGN=CENTER>
<TD>
NL
<TD>
newline
<TD>
\n
<TR ALIGN=CENTER>
<TD>
CR
<TD>
carriage return
<TD>
\r
<TR ALIGN=CENTER>
<TD>
space
<TD>
space
<TD>
\s
<TR ALIGN=CENTER>
<TD>
HT
<TD>
tab
<TD>
\t
<TR ALIGN=CENTER>
<TD>
VT
<TD>
vertical tab
<TD>
\v
</TABLE>
<P>
Any other characters following a backslash simply become themselves.
This can be used to "turn off" the normal interpretation of certain
characters.
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Example Escaped Interpretations</CAPTION>
<TR ALIGN=CENTER>
<TD>
<STRONG>Sequence</STRONG>
<TD>
<STRONG>Indicates</STRONG>
<TD>
<STRONG>Commonly Used</STRONG>
<TR ALIGN=CENTER>
<TD>
\,
<TD>
a comma
<TD>
in the expression field
<TR ALIGN=CENTER>
<TD>
\"
<TD>
a double quote mark
<TD>
within literal strings
<TR ALIGN=CENTER>
<TD>
\\
<TD>
a single backslash
<TD>
within literal strings
</TABLE>
<P>
<STRONG>Hexadecimal Escape Sequences</STRONG>
<P>
Hexadecimal escapes take the form of a backslash ('\') followed by
a hexadecimal number in Motorola, Intel or C formats.
When a hexadecimal escape is recognized the longest possible sequence of
successive legal hexadecimal digits will be accepted, but at most only
the final two will determine the value of the sequence.
That is, the hexadecimal value can be considered as being bit-wise ANDed
with the hexadecimal value $FF, producing a value in the range $00-FF.
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Example Hexadecimal Escape Sequences</CAPTION>
<TR ALIGN=CENTER>
<TD>
<STRONG>Decimal</STRONG>
<TD>
<STRONG>Motorola Escape</STRONG>
<TD>
<STRONG>Intel Escape</STRONG>
<TD>
<STRONG>C Escape</STRONG>
<TR ALIGN=CENTER>
<TD>
12
<TD>
\$00C
<TD>
\0CH
<TD>
\0x0C
<TR ALIGN=CENTER>
<TD>
128
<TD>
\$80
<TD>
\0080H
<TD>
\0x80
<TR ALIGN=CENTER>
<TD>
254
<TD>
\$FE
<TD>
\0FEH
<TD>
\0x12345FE
</TABLE>
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l15">Character Literals</A>
<LI>
<A HREF="hxa_test.htm#l24">String Literals</A>
<LI>
<A HREF="hxa_test.htm#l16">Expression Evaluation</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l29">Symbols</A>
</BIG>
</STRONG>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l2b">Numeric Labels</A>
</BIG>
</STRONG>
</CENTER>
<P>
<A HREF="#l35">Global</A>
, 
<A HREF="#l35">local</A>
 and 
<A HREF="#l35">variable</A>
numeric labels may be used wherever a numeric value is expected.
When referenced, the value of the label is used during evaluation.
<P>
References to 
<A HREF="#l35">branch target</A>
 labels in an expression consist of
a colon (':') character immediately followed by one or more plus ('+') or
minus ('-') signs.
Sequences of plus signs designate forward references, while sequences
of minus signs designate backward references.
<P>
For example, in an expression '
<STRONG>:+</STRONG>
' refers to the next forward branch
target label from the current position, '
<STRONG>:++</STRONG>
' to the second,
'
<STRONG>:+++</STRONG>
' to the third, and so on.
The expression '
<STRONG>:-</STRONG>
' refers to the most recent preceeding backward
branch target label, '
<STRONG>:--</STRONG>
' to the one before that, and so on.
<P>
HXA is not confused by branch target references of any length or distance,
but programmers may find that beyond the nearest three or so
in either direction they become difficult to follow in source code.
<P>
With the colon prefix, branch target references can be used in any
numeric expression (although they may need to separated from an immediately
following plus or minus sign by a space).
If a branch target reference is the only term in an expression
(ie., it appears alone without any other operators or operands),
then the colon prefix is optional and may be omitted.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l12">All Label Forms</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l2d">String Labels</A>
</BIG>
</STRONG>
</CENTER>
<P>
<A HREF="#l35">Global</A>
, 
<A HREF="#l35">local</A>
 and 
<A HREF="#l35">variable</A>
string labels may be used wherever a string value is expected.
When referenced, the value of the label is used during evaluation.
<P>
String labels may also be used in some circumstances where a numeric
value is expected.
In these cases a string value is subject to an implied comparison against
the null string before any numeric operator is applied.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l23">String Labels</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l2c">Program Counter</A>
</BIG>
</STRONG>
</CENTER>
<P>
The current value of the program counter is represented in expressions
by either an asterisk ('*') or a dollar sign ('$').
<P>
The minimum program counter value is zero.
The maximum is between 2^8-1 and 2^32-1, depending on the processor in use.
<P>
The program counter value may be used wherever a numeric value is expected.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l1d">Program Counter Reference</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l2a">Forward Reference</A>
</BIG>
</STRONG>
</CENTER>
<P>
A symbol is 
<EM>forward referenced</EM>
 when it is used as an operand in an
expression but its actual value is not known at that time.
<P>
In a monolithic program only labels have this property.
It is assumed that sooner or later the label will appear in the
<A HREF="#l86">label field</A>
 and thereby acquire a known value.
<P>
In a 
<A HREF="#l79">segmented</A>
 program, every segment that is
not 
<EM>absolute origin</EM>
 has only unknown values for both its labels and
its program counter until after the first pass is complete.
It is assumed that at that time their values will become fixed.
<P>
HXA allows forward reference in any construct which ultimately generates
code or data of a known size, such as instruction opcodes or
<A HREF="#l54">"BIT--"</A>
 pseudo ops.
HXA saves any partially evaluated expression and completes evaluation
during the second pass.
At this point all program counters have been made absolute
and the value of all labels is known.
<P>
HXA forbids forward reference whenever the value of an expression must
be known during the first pass.
These situations include conditional pseudo ops, because HXA must make
a decision when the expression is first encountered.
Other pseudo ops such as 
<A HREF="#l7a">"STRING--"</A>
 and 
<A HREF="#l61">"HEX"</A>
 advance
the program counter by an amount that must be known during the first pass,
so they too do not allow forward reference.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l0b">Functions</A>
</BIG>
</STRONG>
</CENTER>
<P>
<UL>
<LI><A HREF="#l0c">CHR$()</A>
<LI><A HREF="#l0d">CPU$()</A>
<LI><A HREF="#l0e">DEFINED()</A>
<LI><A HREF="#l0f">EMPTY()</A>
<LI><A HREF="#l10">FILE$()</A>
<LI><A HREF="#l11">FORWARD()</A>
<LI><A HREF="#l12">INDEX()</A>
<LI><A HREF="#l13">INDEXR()</A>
<LI><A HREF="#l14">LABEL()</A>
<LI><A HREF="#l15">LEN()</A>
<LI><A HREF="#l16">MATCH$()</A>
<LI><A HREF="#l17">MESG$()</A>
<LI><A HREF="#l18">MID$()</A>
<LI><A HREF="#l19">ORD()</A>
<LI><A HREF="#l1a">PEEK$()</A>
<LI><A HREF="#l1b">POP$()</A>
<LI><A HREF="#l1c">SEG--()</A>
<LI><A HREF="#l1d">STR$()</A>
<LI><A HREF="#l1e">TIME$()</A>
<LI><A HREF="#l1f">TOLOWER$() and TOUPPER$()</A>
<LI><A HREF="#l20">VAL()</A>
<LI><A HREF="#l21">VER() and VER$()</A>
<LI><A HREF="#l22">XLATE()</A>
</UL>
<P>
Conventions
<UL>
<LI>
function arguments are noted in 
<EM>italic</EM>
<LI>
optional arguments are surrounded by square brackets (
<EM>[optional]</EM>
)
</UL>
<P>
Argument Types
<UL>
<LI>
<EM>num_expr</EM>
: an 
<A HREF="#l04">expression</A>
 which evaluates
to an integer number
<LI>
<EM>str_expr$</EM>
: an expression which evaluates to a string
<LI>
<EM>name$</EM>
: an identifier which has the same form as a global label.
It may be specified either literally or as a string expression
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l0c">CHR$()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>CHR$(</STRONG>
<EM>num_expr</EM>
<STRONG>)</STRONG>
</CODE>
<P>
CHR$() returns a string of length one whose single character has
the value 
<EM>num_expr & $FF</EM>
.
The bitwise-AND ensures that the value will fit in a single 8-bit character.
<P>
CHR$() is not affected by 
<A HREF="#l83">character set translation</A>
.
<P>
CHR$() is the inverse of 
<A HREF="#l19">ORD()</A>
.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l31">CHR$() and ORD()</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l0d">CPU$()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage 
<STRONG>CPU$()</STRONG>
</CODE>
<P>
CPU$() returns the name of the current processor as an uppercase string.
If a processor has not yet been specified (by using the 
<A HREF="#l57">CPU</A>
 pseudo
opcode), CPU$() returns the null string.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l32">CPU$()</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l0e">DEFINED()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>DEFINED(</STRONG>
<EM>name$</EM>
<STRONG>)</STRONG>
</CODE>
<P>
DEFINED() returns logical TRUE if its argument
is a currently defined 
<A HREF="#l68">macro</A>
,
otherwise logical FALSE.
<P>
A non-fatal error occurs if 
<EM>name$</EM>
 is a string expression which
does not evaluate to the form of a global name.
The expression containing DEFINED() is treated as incompletely evaluated.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l52">DEFINED() and UNDEF</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l0f">EMPTY()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>EMPTY()</STRONG>
</CODE>
<P>
EMPTY() returns logical TRUE if the user string stack is empty,
otherwise logical FALSE.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l66">User Stack</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l10">FILE$()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>FILE$()</STRONG>
</CODE>
<P>
FILE$() returns the base name of the current source file, either
root or include, as an uppercase string.
No path or directory information is included.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l33">FILE$()</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l11">FORWARD()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>FORWARD(</STRONG>
<EM>str_expr$</EM>
<STRONG>)</STRONG>
</CODE>
<P>
FORWARD() returns logical TRUE if
<EM>str_expr$</EM>
, converted to a numeric expression, contains one or more 
<A HREF="#l2a">forward references</A>
,
otherwise logical FALSE.
<P>
A non-fatal error occurs if 
<EM>str_expr$</EM>
 cannot be converted
to a legal numeric expression.
The expression containing FORWARD() is treated as incompletely evaluated.
<P>
Because a label by itself is a legal expression, FORWARD() can be used to
determine if a numeric label is in the symbol table.
FORWARD() returns FALSE if it is, TRUE if it is not.
<P>
Used in the manner, FORWARD() is similar to 
<A HREF="#l14">LABEL()</A>
, but returns the
opposite sense.
Unlike 
<A HREF="#l14">LABEL()</A>
, FORWARD() works for any numeric label type, not just
globals.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l34">FORWARD()</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l12">INDEX()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>INDEX(</STRONG>
<EM>str_expr1$, str_expr2$ [, num_expr]</EM>
<STRONG>)</STRONG>
</CODE>
<P>
INDEX() returns the leftmost starting index of
<EM>str_expr2$</EM>
 in 
<EM>str_expr1$</EM>
.
<P>
If 
<EM>str_expr2$</EM>
 does not occur in 
<EM>str_expr1$</EM>
, the result is zero.
<P>
If either string argument is the null string, the result is zero.
<P>
If 
<EM>num_expr</EM>
 is not present, the search begins at index one
(the first, or leftmost, character of 
<EM>str_expr1$</EM>
).
<P>
If the absolute value of 
<EM>num_expr</EM>
 is between one and LEN(
<EM>str_expr1$</EM>
)
inclusive, the search begins using that value as the starting index.
If 
<EM>num_expr</EM>
 is positive the index is counted from the start of the string
toward its end.
If 
<EM>num_expr</EM>
 is negative the index is counted from the end of the string
toward its start.
<P>
For any other value of 
<EM>num_expr</EM>
 the result is zero.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l36">INDEX()</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l13">INDEXR()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>INDEXR(</STRONG>
<EM>str_expr1$, str_expr2$ [, num_expr]</EM>
<STRONG>)</STRONG>
</CODE>
<P>
INDEXR() function returns the rightmost starting index of
<EM>str_expr2$</EM>
 in 
<EM>str_expr1$</EM>
.
<P>
If 
<EM>str_expr2$</EM>
 does not occur in 
<EM>str_expr1$</EM>
, the result is zero.
<P>
If either string argument is the null string, the result is zero.
<P>
If 
<EM>num_expr</EM>
 is not present, the search begins at index LEN(
<EM>str_expr1$</EM>
)
(the last, or rightmost, character of 
<EM>str_expr1$</EM>
).
<P>
If the absolute value of 
<EM>num_expr</EM>
 is between one and LEN(
<EM>str_expr1$</EM>
)
inclusive, the search begins using that value as the starting index.
If 
<EM>num_expr</EM>
 is positive the index is counted from the start of the string
toward its end.
If 
<EM>num_expr</EM>
 is negative the index is counted from the end of the string
toward its start.
<P>
For any other value of 
<EM>num_expr</EM>
 the result is zero.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l37">INDEXR()</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l14">LABEL()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>LABEL(</STRONG>
<EM>name$</EM>
<STRONG>)</STRONG>
</CODE>
<P>
LABEL() returns logical TRUE if its argument is a global numeric name
currently present in the symbol table, otherwise logical FALSE.
<P>
A non-fatal error occurs if 
<EM>name$</EM>
 is a string expression which
does not evaluate to the form of a global name.
The expression containing LABEL() is treated as incompletely evaluated.
<P>
LABEL() interrogates the symbol table directly, but only works for global
numeric labels.
Because a label by itself is a legal expression, 
<A HREF="#l11">FORWARD()</A>
 can
be used to indirectly determine the existence of any numeric label tpe.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l38">LABEL()</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l15">LEN()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>LEN(</STRONG>
<EM>str_expr$</EM>
<STRONG>)</STRONG>
</CODE>
<P>
LEN() returns the number of 8-bit character codes in 
<EM>str_expr$</EM>
.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l39">LEN()</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l16">MATCH$()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>MATCH$(</STRONG>
<EM>str_expr$, regex [, num_expr]</EM>
<STRONG>)</STRONG>
</CODE>
<P>
MATCH$() returns the leftmost substring of 
<EM>str_expr$</EM>
 that matches
the regular expression pattern 
<EM>regex</EM>
.
If 
<EM>regex</EM>
 does not match 
<EM>str_exrpr</EM>
, the result is the null string.
<P>
If 
<EM>num_expr</EM>
 is not present, the search begins at index one
(the first, or leftmost, character of 
<EM>str_expr$</EM>
).
<P>
If the absolute value of 
<EM>num_expr</EM>
 is between one and LEN(
<EM>str_expr1$</EM>
)
inclusive, the search begins using that value as the starting index.
If 
<EM>num_expr</EM>
 is positive the index is counted from the start of the string
toward its end.
If 
<EM>num_expr</EM>
 is negative the index is counted from the end of the string
toward its start.
<P>
For any other value of 
<EM>num_expr</EM>
 the result is the null string.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l3a">MATCH$()</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l17">MESG$()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>MESG$(</STRONG>
<EM>str_expr$</EM>
<STRONG>)</STRONG>
</CODE>
<P>
MESG$() returns the full text of any message HXA can display.
<P>
<EM>Str_expr$</EM>
 is an index into the
<A HREF="hxa_mesg.htm">table of messages</A>
.
If 
<EM>str_expr$</EM>
 is not found, the "BadMsg" index message is returned
with 
<EM>str_expr$</EM>
 flagged as part of the text.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l3b">MESG$()</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l18">MID$()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>MID$(</STRONG>
<EM>str_expr$, num_expr1 [, num_expr2]</EM>
<STRONG>)</STRONG>
</CODE>
<P>
MID$() returns a substring of 
<EM>str_expr$</EM>
.
<P>
If 
<EM>str_expr$</EM>
 is the null string, the result is the null string.
<P>
If the absolute value of 
<EM>num_expr1</EM>
 is between one and LEN(
<EM>str_expr$</EM>
)
inclusive, the substring begins using that position as the starting index.
If 
<EM>num_expr1</EM>
 is positive the index is counted from the start of the string
toward its end.
If 
<EM>num_expr1</EM>
 is negative the index is counted from the end of the string
toward its start.
<P>
For any other value of 
<EM>num_expr1</EM>
 the result is the null string.
<P>
If 
<EM>num_expr2</EM>
 is not present or has a value greater than the number of
characters in 
<EM>str_expr$</EM>
 from the start position to its end,
the returned substring consists of all characters of 
<EM>str_expr$</EM>
from the start position onwards.
<P>
If 
<EM>num_expr2</EM>
 is present and has a value between one and the number of
characters in 
<EM>str_expr$</EM>
 from the start position to the end inclusive,
the returned substring consists of 
<EM>num_expr2</EM>
 characters of 
<EM>str_expr$</EM>
beginning at the start position.
<P>
If 
<EM>num_expr2</EM>
 is less than one the result is the null string.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l3c">MID$()</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l19">ORD()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>ORD(</STRONG>
<EM>str_expr$ [, num_expr]</EM>
<STRONG>)</STRONG>
</CODE>
<P>
ORD() returns the 8-bit numeric value of a character in 
<EM>str_expr$</EM>
.
<P>
If 
<EM>str_expr$</EM>
 is the null string, ORD() returns zero.
<P>
If 
<EM>num_expr</EM>
 is not present, the first character of 
<EM>str_expr$</EM>
 is used.
<P>
If the absolute value of 
<EM>num_expr</EM>
 is between one and LEN(
<EM>str_expr1$</EM>
)
inclusive, the character at that index is used.
If 
<EM>num_expr</EM>
 is positive the index is counted from the start of the string
toward its end.
If 
<EM>num_expr</EM>
 is negative the index is counted from the end of the string
toward its start.
<P>
For any other value of 
<EM>num_expr</EM>
 the result is zero.
<P>
ORD() is not affected by 
<A HREF="#l83">character set translation</A>
.
<P>
ORD() is the inverse of 
<A HREF="#l0c">CHR$()</A>
.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l31">CHR$() and ORD()</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l1a">PEEK$()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>PEEK$(</STRONG>
<EM>[num_expr]</EM>
<STRONG>)</STRONG>
</CODE>
<P>
PEEK$() returns an entry from the user string stack without removing it
from the stack.
<P>
If the optional 
<EM>num_expr</EM>
 argument is not present, PEEK$() returns the
topmost entry on the stack (ie., the string most recently placed on the
stack).
<P>
If 
<EM>num_expr</EM>
 is present and has a value between one and the number of
stack entries inclusive, the entry at that index is returned.
The topmost entry has an index of one, the entry "under" the topmost has
an index of two, and so on.
The bottom entry (ie., the first one placed on the stack) has an index
equal to the total number of entries currently on the stack.
<P>
A non-fatal error occurs if 
<EM>num_expr</EM>
 does not correspond to a stack
entry (eg., is negative or greater than the current number of entries).
The expression containing PEEK$() is treated as incompletely evaluated.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l66">User Stack</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l1b">POP$()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>POP$()</STRONG>
</CODE>
<P>
POP$() returns the topmost entry on the user string stack and removes it
from the stack.
<P>
POP$() is the complement of the 
<A HREF="#l72">PUSHS</A>
 pseudo op, which places strings on
the user stack.
For every use of POP$(), there must be an earlier one of PUSHS.
The numbers must balance by the end of the first pass.
<P>
It is an error to use POP$() on an empty stack.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l66">User Stack</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l1c">SEG--()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>SEG--(</STRONG>
<EM>name$</EM>
<STRONG>)</STRONG>
</CODE>
<P>
Variants
<UL>
<LI>
<STRONG>SEGBEG()</STRONG>
<LI>
<STRONG>SEGEND()</STRONG>
<LI>
<STRONG>SEGLEN()</STRONG>
<LI>
<STRONG>SEGOFF()</STRONG>
</UL>
<P>
SEGBEG() returns the absolute start address of segment 
<EM>name$</EM>
.
That is, the address that contains the first byte used by 
<EM>name$</EM>
.
<P>
SEGEND() returns the absolute end address plus one of segment 
<EM>name$</EM>
.
That is, the address following the last byte used by 
<EM>name$</EM>
.
Note that SEGEND() equals SEGBEG() if nothing has ever caused the
segment program counter to increment.
<P>
SEGLEN() returns the length of segment 
<EM>name$</EM>
.
That is, the value of SEGEND() - SEGBEG().
<P>
SEGOFF() returns the byte offset of segment 
<EM>name$</EM>
 from the first segment.
That is, the sum of the lengths of all data-containing segments before
segment 
<EM>name$</EM>
 in the output sequence.
It is the same as the zero-based byte offset of segment 
<EM>name$</EM>
from the start of a raw binary output file.
<P>
It is an error to use SEGOFF() on 
<A HREF="#l7f">uninitialized</A>
 segments.
They do not appear in output files and thus have no meaningful offset value.
<P>
<EM>name$</EM>
 may be a forward reference to a segment which has not yet been
encountered.
<P>
A non-fatal error occurs if 
<EM>name$</EM>
 is a string expression which
does not evaluate to the form of a global name.
The expression containing SEG--() is treated as incompletely evaluated.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l3d">SEGBEG(), SEGEND(), SEGLEN() and SEGOFF()</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l1d">STR$()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>STR$(</STRONG>
<EM>num_expr</EM>
<STRONG>)</STRONG>
</CODE>
<P>
STR$() converts 
<EM>num_expr</EM>
 to a string consisting of its decimal
representation.
<P>
A non-fatal error occurs if 
<EM>num_expr</EM>
 is not in the range of
a signed or unsigned 32-bit integer.
The expression containing STR$() is treated as incompletely evaluated.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l3e">STR$()</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l1e">TIME$()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>TIME$()</STRONG>
</CODE>
<P>
TIME$() returns the current time as a string in the form:
<P>
"Sat May 28 17:49:30 2011"
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l3f">TIME$()</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l1f">TOLOWER$() and TOUPPER$()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>TOLOWER$(</STRONG>
<EM>str_expr$</EM>
<STRONG>)</STRONG>
Useage: 
<STRONG>UPPER$(</STRONG>
<EM>str_expr$</EM>
<STRONG>)</STRONG>
</CODE>
<P>
TOLOWER$() returns a string the same as 
<EM>str_expr$</EM>
, except that
any upper case alphabetic characters have been converted to lower case.
<P>
TOUPPER$() returns a string the same as 
<EM>str_expr$</EM>
, except that
any lower case alphabetic characters have been converted to upper case.
<P>
Examples
<UL>
<LI>
<A HREF=".htm">TOLOWER$() and TOUPPER$()</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l20">VAL()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>VAL(</STRONG>
<EM>str_expr$</EM>
<STRONG>)</STRONG>
</CODE>
<P>
VAL() converts 
<EM>str_expr$</EM>
 to a numeric expression and evaluates it.
The converted expression may use
<A HREF="#l2a">forward reference</A>
in any context it is normally allowed.
<P>
A non-fatal error occurs if 
<EM>str_expr$</EM>
 cannot be converted
to a legal numeric expression.
The expression containing VAL() is treated as incompletely evaluated.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l41">VAL()</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l21">VER() and VER$()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>VER()</STRONG>
</CODE>
<P>
<CODE>
Useage: 
<STRONG>VER$()</STRONG>
</CODE>
<P>
VER() has no arguments and returns the HXA version number.
<P>
This value is decimal coded by nybbles (4-bits), or BCD encoding.
<P>
Bit Interpretation
<UL>
<LI>
00 - 03 : bug fix and/or internal revision with no external change
<LI>
04 - 07 : minor version number, hundredths place
<LI>
08 - 11 : minor version number, tenths place
<LI>
12 - 31 : major version number
</UL>
<P>
Examples:
<UL>
<LI>
$00000100 -&gt; v0.100  (the lowest actually released version number)
<LI>
$00000121 -&gt; v0.121  (a bugfix release)
<LI>
$00000200 -&gt; v0.200  (this release - an upgrade release)
<LI>
$00001000 -&gt; v1.000  (the first major release - hasn't happened yet)
</UL>
<P>
It is unlikely that 99,999 major versions will ever be released.
<P>
VER$() has no arguments and returns the HXA version name in the form:
<P>
"HXA v0.200"
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l42">VER() and VER$()</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l22">XLATE()</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
Useage: 
<STRONG>XLATE(</STRONG>
<EM>num_expr</EM>
<STRONG>)</STRONG>
</CODE>
<P>
XLATE() returns the numeric value at index 
<EM>num_expr & $FF</EM>
in the current 
<A HREF="#l83">character set translation</A>
 table.
The bitwise-AND ensures the index is always within the range zero to 255,
the size of the translation table.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l28">XLATE() and XLATE</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l2e">Operators</A>
</BIG>
</STRONG>
</CENTER>
<P>
HXA provides operators which work with numeric, string and regular
expression operands.
Results can be numeric or string (logical operator results are
either zero (FALSE) or one (TRUE)).
<P>
Each operator has an associated precedence which determines the
order in which operators are applied to operands.
In the standard algebraic manner, groups of operands and operators
inside pairs of parentheses will be evaluated before those outside,
and sets of parentheses nest.
<P>
Although some assembly languages use pairs of parentheses to indicate
address indirection, this usually does not cause HXA any difficulty.
When used as address indirection indicators, parentheses normally surround
the entire expression of interest.
The value of an entire expression surrounded by parentheses is no different
than the value of the same expression 
<EM>not</EM>
 surrounded by parentheses,
so no special treatment is required by HXA.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l2f">Operator Precedence</A>
</BIG>
</STRONG>
</CENTER>
<P>
Operators are arranged in order of precedence, from highest to lowest.
Those of higher precedence are evaluated before those of lower precedence.
<P>
Operators grouped together have equal precedence.
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Expression Operators</CAPTION>
<TR ALIGN=CENTER>
<TD>
<STRONG>Operator</STRONG>
<TD>
<STRONG>Notation</STRONG>
<TD>
<STRONG>Result Type</STRONG>
<TR ALIGN=CENTER>
<TD>
---
<TD>
---
<TD>
---
<TR ALIGN=CENTER>
<TD>
Built-in Functions
<TD>
F()
<TD>
Any
<TR ALIGN=CENTER>
<TD>
---
<TD>
---
<TD>
---
<TR ALIGN=CENTER>
<TD>
String Concatenation
<TD>
S1 S2
<TD>
String
<TR ALIGN=CENTER>
<TD>
---
<TD>
---
<TD>
---
<TR ALIGN=CENTER>
<TD>
String Equal
<TD>
S1 == S2
<TD>
Logical
<TR ALIGN=CENTER>
<TD>
String NOT Equal
<TD>
S1 != S2
<TR ALIGN=CENTER>
<TD>
String Less Than
<TD>
S1 &lt; S2
<TR ALIGN=CENTER>
<TD>
String Greater Than
<TD>
S1 &gt; S2
<TR ALIGN=CENTER>
<TD>
String Less Than or Equal
<TD>
S1 &lt;= S2
<TR ALIGN=CENTER>
<TD>
String Greater Than or Equal
<TD>
S1 &gt;= S2
<TR ALIGN=CENTER>
<TD>
---
<TD>
---
<TD>
---
<TR ALIGN=CENTER>
<TD>
String Matches Regular Expression
<TD>
S ~ RE
<TD>
Logical
<TR ALIGN=CENTER>
<TD>
String NOT Match Regular Expression
<TD>
S !~ RE
<TR ALIGN=CENTER>
<TD>
---
<TD>
---
<TD>
---
<TR ALIGN=CENTER>
<TD>
Unary Plus
<TD>
+N
<TD>
Numeric
<TR ALIGN=CENTER>
<TD>
Unary Minus
<TD>
-N
<TR ALIGN=CENTER>
<TD>
Logical NOT
<TD>
!N
<TD>
Logical
<TR ALIGN=CENTER>
<TD>
Bitwise NOT
<TD>
~N
<TD>
Numeric
<TR ALIGN=CENTER>
<TD>
Extract Bits 0..7
<TD>
&lt;N
<TR ALIGN=CENTER>
<TD>
Extract Bits 8..15
<TD>
&gt;N
<TR ALIGN=CENTER>
<TD>
Extract Bits 16..31
<TD>
^N
<TR ALIGN=CENTER>
<TD>
---
<TD>
---
<TD>
---
<TR ALIGN=CENTER>
<TD>
Multiply
<TD>
N1 * N2
<TD>
Numeric
<TR ALIGN=CENTER>
<TD>
Divide
<TD>
N1 / N2
<TR ALIGN=CENTER>
<TD>
Remainder (aka Modulus)
<TD>
N1 % N2
<TR ALIGN=CENTER>
<TD>
---
<TD>
---
<TD>
---
<TR ALIGN=CENTER>
<TD>
Add
<TD>
N1 + N2
<TD>
Numeric
<TR ALIGN=CENTER>
<TD>
Subtract
<TD>
N1 - N2
<TR ALIGN=CENTER>
<TD>
---
<TD>
---
<TD>
---
<TR ALIGN=CENTER>
<TD>
Left Shift
<TD>
N1 &lt;&lt; N2
<TD>
Numeric
<TR ALIGN=CENTER>
<TD>
Right Shift
<TD>
N1 &gt;&gt; N2
<TR ALIGN=CENTER>
<TD>
---
<TD>
---
<TD>
---
<TR ALIGN=CENTER>
<TD>
Less Than
<TD>
N1 &lt; N2
<TD>
Logical
<TR ALIGN=CENTER>
<TD>
Greater Than
<TD>
N1 &gt; N2
<TR ALIGN=CENTER>
<TD>
Less Than or Equal
<TD>
N1 &lt;= N2
<TR ALIGN=CENTER>
<TD>
Greater Than or Equal
<TD>
N1 &gt;= N2
<TR ALIGN=CENTER>
<TD>
---
<TD>
---
<TD>
---
<TR ALIGN=CENTER>
<TD>
Equal
<TD>
N1 == N2
<TD>
Logical
<TR ALIGN=CENTER>
<TD>
NOT Equal
<TD>
N1 != N2
<TR ALIGN=CENTER>
<TD>
---
<TD>
---
<TD>
---
<TR ALIGN=CENTER>
<TD>
Bitwise AND
<TD>
N1 & N2
<TD>
Numeric
<TR ALIGN=CENTER>
<TD>
---
<TD>
---
<TD>
---
<TR ALIGN=CENTER>
<TD>
Bitwise Exclusive OR
<TD>
N1 ^ N2
<TD>
Numeric
<TR ALIGN=CENTER>
<TD>
---
<TD>
---
<TD>
---
<TR ALIGN=CENTER>
<TD>
Bitwise Inclusive OR
<TD>
N1 | N2
<TD>
Numeric
<TR ALIGN=CENTER>
<TD>
---
<TD>
---
<TD>
---
<TR ALIGN=CENTER>
<TD>
Logical AND
<TD>
N1 && N2
<TD>
Logical
<TR ALIGN=CENTER>
<TD>
---
<TD>
---
<TD>
---
<TR ALIGN=CENTER>
<TD>
Logical OR
<TD>
N1 || N2
<TD>
Logical
<TR ALIGN=CENTER>
<TD>
---
<TD>
---
<TD>
---
<TR ALIGN=CENTER>
<TD>
Conditional
<TD>
cond_expr ? true_expr : false_expr
<TD>
Any
</TABLE>
<P>
Notes:
<UL>
<LI>
operator precedence is the same as the C/C++ family of languages whereever
operators are the same
<LI>
the string concatenation "operator" is implied by adjacent string operands
<LI>
string operators have a higher precedence than any numeric operator
because this is perhaps the simplest way to ensure
that numeric operators do not try to engage string operands
<LI>
the pattern match operators are 
<EM>not</EM>
 commutative.
The string operand must appear to the left of the operator
and the regular expression pattern to the right
<LI>
division or modulus by zero causes a non-fatal error and the expression
is treated as incompletely evaluated
<LI>
the bit extraction operators are affected by 
<A HREF="#l40">non-standard byte sizes</A>
</UL>
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l16">Expression Evaluation</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l31">Unary Operators</A>
</BIG>
</STRONG>
</CENTER>
<P>
Consecutive unary operators of equal precedence
are evaluated right-to-left, rather than left-to-right.
<P>
The unary plus operator yields the absolute value of its operand.
<P>
The "bit extract" operators ('&lt;', '&gt;' and '^') are essentially shorthand for
a right shift (to move the bits of interest to the least significant
bit positions) followed by a bitwise AND (to set the bits not of interest
to zero).
The resultant value is a full 32 bits long (and usually a positive integer).
<P>
The "bit extract" operators are affected by 
<A HREF="#l40">non-standard byte sizes</A>
.
In general, '&lt;' always refers to the least significant byte, '&gt;' to the
next significant byte, and '^' to the most significant word.
These concepts change when the size of a "byte" changes.
<P>
If unary operators are applied to string operands, the strings are
implicitly compared to the null string before the operator is applied.
The final result is numeric.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l06">Logical Short Circuit</A>
</BIG>
</STRONG>
</CENTER>
<P>
The logical operators AND (&&) and OR (||) generally have the form
<EM>cond_expr1 op cond_expr2</EM>
.
If the result of 
<EM>op</EM>
 can be determined by evaluating just 
<EM>cond_expr1</EM>
,
these operators 
<EM>short circuit</EM>
, skipping over 
<EM>cond_expr2</EM>
 without
evaluating it.
<P>
For example, if 
<EM>cond_expr1</EM>
 has a value of zero, the result of logical
AND must be zero whatever the value of 
<EM>cond_expr2</EM>
 is.
Thus there is no need to evaluate it.
<P>
The types of 
<EM>cond_expr1</EM>
 and 
<EM>cond_expr2</EM>
 must match, both being either
numeric (TRUE if non-zero) or string (TRUE if non-null).
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l30">Ternary Conditional</A>
</BIG>
</STRONG>
</CENTER>
<P>
The ternay conditional 
<EM>cond_expr ? true_expr : false_expr</EM>
 accepts
multiple expression types in all branches.
<P>
<EM>Cond_expr</EM>
 may be either numeric (TRUE if non-zero) or
string (TRUE if non-null).
<P>
<EM>True_expr</EM>
 and 
<EM>false_expr</EM>
 must both have the same type.
They can be numeric, strings, global names or regular expressions,
as long as their type is correct in context.
<P>
In some cases a 
<EM>true_expr</EM>
 or 
<EM>false_expr</EM>
 or both may be coerced
to the expected type.
For example, numbers to strings or strings to global names.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l32">Undetected Errors</A>
</BIG>
</STRONG>
</CENTER>
<P>
In some cases an expression may contain an error which might not be detected
by HXA.
Undetected errors may be of two general kinds, 
<EM>parse</EM>
 and 
<EM>unevaluable</EM>
.
<P>
A parse error occurs when an expression is malformed.
In some cases HXA may not detect this because no parse is attempted.
For example, in false 
<A HREF="#l63">"IF"</A>
 conditional branchs
HXA does not attempt to parse any expression following a nested "IF" or
"ELSEIF" pseudo opcode because no result of any subsequent evaluation can
change a false branch to true.
<P>
An unevaluable error occurs when an expression parses properly but
can never be fully evaluated (eg., it contains an unresolvable
<A HREF="#l2a">forward reference</A>
 or a division by zero).
In some cases HXA may not detect this because evaluation is never attempted.
The logical operators "&&" and "||" and the ternary operator "?:" can cause
part of the expression they appear in to be skipped over during evaluation.
HXA does not determine whether or not skipped-over parts can be evaluated.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l05">Caching</A>
</BIG>
</STRONG>
</CENTER>
<P>
HXA handles expressions in two phases.
Each expression is first converted to an internal form.
If that succeeds without error, the internal form is then evaluated.
<P>
Conversion to internal form can take a significant amount of time.
If any single expression is heavily used, it usually pays to convert it once
and then cache the internal form.
Evaluation then happens on the quickly-fetched cached internal form.
<P>
HXA automatically caches expressions which meet two conditions.
First, to increase the chance any particular expression is heavily used,
it must occur inside a 
<A HREF="#l68">macro</A>
 expansion.
Second, to increase the chance conversion is actually time-consuming,
it must have at least one operator (ie., expressions consisting
of a lone operand are not cached).
<P>
HXA periodically purges its expression cache every time it reaches
a certain size, in part to eliminate infrequently used cached expressions.
<P>
Programmers may take advantage of this caching strategy when designing macros.
The basic idea is to minimize the number of variant expressions encountered.
One way to accomplish this is to place the results of argument
evaluations into variable labels, then using the variable labels within
expressions in the remainder of the macro body.
Since their parsing then does not change when the macro arguments change,
their cached values can be used repeatedly.
<P>
Even better results can be had if the same expressions using the same
variable labels can be used in multiple macros.
This can frequently be easily be arranged, for example if the macros are
being used to simulate a processor instruction set.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=50%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l49">Pseudo Opcodes</A>
</BIG>
</STRONG>
</CENTER>
<P>
<EM>Pseudo opcodes</EM>
 (or 
<EM>pseudo ops</EM>
) appear in the opcode field of a
source code line but are not processor instruction opcodes.
Instead they control the assembler itself (and so are sometimes also
called 
<EM>assembler directives</EM>
).
They provide facilities such as data storage,
conditional assembly, macro assembly and file inclusion.
<P>
HXA's pseudo ops may be optionally prefixed with a period ('.') or
sharp ('#') character.
These are allowed merely for visual distinctiveness, however.
HXA disregards these prefix characters when identifying a pseudo op,
so conflicts with user names should be avoided.
<P>
There are built-in aliases for many HXA pseudo ops.
Programmers may use either the base form or the alias with identical results.
The 
<A HREF="#l70">"PSALIAS"</A>
 pseudo op allows further aliasing if desired.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l4a">Alphabetic Ordering</A>
</BIG>
</STRONG>
</CENTER>
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Pseudo Opcodes</CAPTION>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l4f">ABSEND</A>
<TD>
<A HREF="#l52">ASSERT</A>
<TD>
<A HREF="#l53">ASSUME</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l54">BIT08</A>
<TD>
<A HREF="#l54">BIT16</A>
<TD>
<A HREF="#l54">BIT16R</A>
<TD>
<A HREF="#l54">BIT24</A>
<TD>
<A HREF="#l54">BIT24R</A>
<TD>
<A HREF="#l54">BIT32</A>
<TD>
<A HREF="#l54">BIT32R</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l55">BYTE</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l56">COMMON</A>
<TD>
<A HREF="#l57">CPU</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l58">DS</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l59">ECHO</A>
<TD>
<A HREF="#l63">ELSE</A>
<TD>
<A HREF="#l63">ELSEIF</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l5a">END</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l63">ENDIF</A>
<TD>
<A HREF="#l68">ENDMACRO</A>
<TD>
<A HREF="#l77">ENDREPEAT</A>
<TD>
<A HREF="#l79">ENDSEGMENT</A>
<TD>
<A HREF="#l82">ENDWHILE</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l50">ERRFILE</A>
<TD>
<A HREF="#l5c">ERROR</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l5b">EQU</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l5e">EXIT</A>
<TD>
<A HREF="#l5e">EXITIF</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l5f">FATAL</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l60">FILL</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l61">HEX</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l50">HEXFILE</A>
<TD>
<A HREF="#l4d">HEXBYBLOCK</A>
<TD>
<A HREF="#l4e">HEXBYSEG</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l63">IF</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l62">IFDEF</A>
<TD>
<A HREF="#l62">IFNDEF</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l64">INCBIN</A>
<TD>
<A HREF="#l65">INCLUDE</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l66">LINESPACE</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l50">LISTFILE</A>
<TD>
<A HREF="#l67">LISTOFF</A>
<TD>
<A HREF="#l67">LISTON</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l55">LONG</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l68">MACRO</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l69">MARGINS</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l6a">MAXDEPTH</A>
<TD>
<A HREF="#l6a">MAXERR</A>
<TD>
<A HREF="#l6a">MAXPUTBACK</A>
<TD>
<TD>
<A HREF="#l6a">MAXSTACK</A>
<TD>
<A HREF="#l6a">MAXWARN</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l6b">MESGTEXT</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l4d">OBJBYBLOCK</A>
<TD>
<A HREF="#l4e">OBJBYSEG</A>
<TD>
<A HREF="#l50">OBJFILE</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l6c">ORG</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l6e">PAGE</A>
<TD>
<A HREF="#l6f">PAGESIZE</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l6d">PADTO</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l70">PSALIAS</A>
<TD>
<A HREF="#l71">PSNULL</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l72">PUSHS</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l73">PUTBACK</A>
<TD>
<A HREF="#l73">PUTBACKS</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l74">RBIT08</A>
<TD>
<A HREF="#l74">RBIT16</A>
<TD>
<A HREF="#l74">RBIT16R</A>
<TD>
<A HREF="#l74">RBIT24</A>
<TD>
<A HREF="#l74">RBIT24R</A>
<TD>
<A HREF="#l74">RBIT32</A>
<TD>
<A HREF="#l74">RBIT32R</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l75">READONCE</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l4f">RELEND</A>
<TD>
<A HREF="#l76">RELORG</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l77">REPEAT</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l51">SHOWTIMER</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l4d">SRECBYBLOCK</A>
<TD>
<A HREF="#l4e">SRECBYSEG</A>
<TD>
<A HREF="#l50">SRECFILE</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l51">STARTTIMER</A>
<TD>
<A HREF="#l51">STOPTIMER</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l78">SBIT08</A>
<TD>
<A HREF="#l78">SBIT16</A>
<TD>
<A HREF="#l78">SBIT16R</A>
<TD>
<A HREF="#l78">SBIT24</A>
<TD>
<A HREF="#l78">SBIT24R</A>
<TD>
<A HREF="#l78">SBIT32</A>
<TD>
<A HREF="#l78">SBIT32R</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l79">SEGMENT</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l7a">STRING</A>
<TD>
<A HREF="#l7a">STRINGR</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l7c">TITLE</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l7d">UBIT08</A>
<TD>
<A HREF="#l7d">UBIT16</A>
<TD>
<A HREF="#l7d">UBIT16R</A>
<TD>
<A HREF="#l7d">UBIT24</A>
<TD>
<A HREF="#l7d">UBIT24R</A>
<TD>
<A HREF="#l7d">UBIT32</A>
<TD>
<A HREF="#l7d">UBIT32R</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l7e">UNDEF</A>
<TD>
<A HREF="#l7f">UNINITIALIZED</A>
<TD>
<A HREF="#l80">USESEGMENTS</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l81">WARN</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l82">WHILE</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l55">WORD</A>
<TR ALIGN=CENTER>
<TD>
<A HREF="#l83">XLATE</A>
</TABLE>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l4b">Functional Ordering</A>
</BIG>
</STRONG>
</CENTER>
<P>
Set CPU
<UL>
<LI>
<A HREF="#l57">CPU</A>
</UL>
<P>
Set Program Counter
<UL>
<LI>
<A HREF="#l6c">ORG</A>
</UL>
<P>
Assign Label Value
<UL>
<LI>
<A HREF="#l58">DS</A>
<LI>
<A HREF="#l5b">EQU</A>
</UL>
<P>
Data Storage
<UL>
<LI>
<A HREF="#l54">BIT--</A>
 : BIT08, BIT16, BIT16R, BIT24, BIT24R, BIT32, BIT32R
<LI>
<A HREF="#l55">BYTE</A>
<LI>
<A HREF="#l61">HEX</A>
<LI>
<A HREF="#l60">FILL</A>
<LI>
<A HREF="#l55">LONG</A>
<LI>
<A HREF="#l6d">PADTO</A>
<LI>
<A HREF="#l74">RBIT--</A>
 : RBIT08, RBIT16, RBIT16R, RBIT24, RBIT24R, RBIT32, RBIT32R
<LI>
<A HREF="#l78">SBIT--</A>
 : SBIT08, SBIT16, SBIT16R, SBIT24, SBIT24R, SBIT32, SBIT32R
<LI>
<A HREF="#l7a">STRING--</A>
 : STRING, STRINGR
<LI>
<A HREF="#l7d">UBIT--</A>
 : UBIT08, UBIT16, UBIT16R, UBIT24, UBIT24R, UBIT32, UBIT32R
<LI>
<A HREF="#l55">WORD</A>
</UL>
<P>
Pass Termination
<UL>
<LI>
<A HREF="#l5a">END</A>
</UL>
<P>
Output Files
<UL>
<LI>
<A HREF="#l4d">--BYBLOCK</A>
 : HEXBYBLOCK, OBJBYBLOCK, SRECBYBLOCK
<LI>
<A HREF="#l4e">--BYSEG</A>
 : HEXBYSEG, OBJBYSEG, SRECBYBLOCK
<LI>
<A HREF="#l50">--FILE</A>
 : ERRFILE, HEXFILE, LISTFILE, OBJFILE, SRECFILE
</UL>
<P>
Macros and Repeat Blocks
<UL>
<LI>
<A HREF="#l5e">EXIT--</A>
 : EXIT, EXITIF
<LI>
<A HREF="#l68">MACRO..ENDMACRO</A>
<LI>
<A HREF="#l73">PUTBACK</A>
<LI>
<A HREF="#l73">PUTBACKS</A>
<LI>
<A HREF="#l77">REPEAT..ENDREPEAT</A>
<LI>
<A HREF="#l7e">UNDEF</A>
</UL>
<P>
Conditional Assembly Blocks
<UL>
<LI>
<A HREF="#l63">IF..ELSEIF..ELSE..ENDIF</A>
<LI>
<A HREF="#l62">IF--DEF</A>
 : IFDEF, IFNDEF
<LI>
<A HREF="#l82">WHILE..ENDWHILE</A>
</UL>
<P>
File Inclusion
<UL>
<LI>
<A HREF="#l64">INCBIN</A>
<LI>
<A HREF="#l65">INCLUDE</A>
<LI>
<A HREF="#l75">READONCE</A>
</UL>
<P>
Segments
<UL>
<LI>
<A HREF="#l4f">ABSEND</A>
<LI>
<A HREF="#l56">COMMON</A>
<LI>
<A HREF="#l79">ENDSEGMENT</A>
<LI>
<A HREF="#l4f">RELEND</A>
<LI>
<A HREF="#l76">RELORG</A>
<LI>
<A HREF="#l79">SEGMENT</A>
<LI>
<A HREF="#l7f">UNINITIALIZED</A>
<LI>
<A HREF="#l80">USESEGMENTS</A>
</UL>
<P>
User Messages
<UL>
<LI>
<A HREF="#l52">ASSERT</A>
<LI>
<A HREF="#l59">ECHO</A>
<LI>
<A HREF="#l5c">ERROR</A>
<LI>
<A HREF="#l5f">FATAL</A>
<LI>
<A HREF="#l81">WARN</A>
</UL>
<P>
Limits
<UL>
<LI>
<A HREF="#l6a">MAX--</A>
 : MAXDEPTH, MAXERR, MAXPUTBACK, MAXSTACK, MAXWARN
</UL>
<P>
Program Listing
<UL>
<LI>
<A HREF="#l66">LINESPACE</A>
<LI>
<A HREF="#l67">LIST--</A>
 : LISTON, LISTOFF
<LI>
<A HREF="#l69">MARGINS</A>
<LI>
<A HREF="#l6e">PAGE</A>
<LI>
<A HREF="#l6f">PAGESIZE</A>
<LI>
<A HREF="#l7c">TITLE</A>
</UL>
<P>
Assembler Customization
<UL>
<LI>
<A HREF="#l53">ASSUME</A>
<LI>
<A HREF="#l6b">MESGTEXT</A>
<LI>
<A HREF="#l70">PSALIAS</A>
<LI>
<A HREF="#l71">PSNULL</A>
<LI>
<A HREF="#l83">XLATE</A>
</UL>
<P>
User Stack
<UL>
<LI>
<A HREF="#l6a">MAXSTACK</A>
<LI>
<A HREF="#l72">PUSHS</A>
</UL>
<P>
Miscellaneous
<UL>
<LI>
<A HREF="#l51">--TIMER</A>
 : STARTTIMER, STOPTIMER, SHOWTIMER
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l4c">Reference</A>
</BIG>
</STRONG>
</CENTER>
<P>
Conventions
<UL>
<LI>
the characters "--" indicate a family of related pseudo ops.
They are all described in the same entry, as they share most characteristics
<LI>
pseudo op arguments are noted in 
<EM>italic</EM>
<LI>
optional arguments are surrounded by square brackets (
<EM>[optional]</EM>
)
<LI>
the characters ".." indicate the preceeding argument may be repeated any
number of times
</UL>
<P>
Argument Types
<UL>
<LI>
<EM>label</EM>
: a 
<A HREF="#l35">symbolic name</A>
.
In most cases can be either numeric or string type
<LI>
<EM>num_expr</EM>
: an 
<A HREF="#l04">expression</A>
 which evaluates
to an integer number
<LI>
<EM>const_expr</EM>
: a numeric expression which does not contain any
<A HREF="#l2a">forward references</A>
<LI>
<EM>str_expr$</EM>
: an expression which evaluates
to a string
<LI>
<EM>const_expr$</EM>
: a string expression which does not contain any
<A HREF="#l2a">forward references</A>
<LI>
<EM>conditional_expr</EM>
: may be either a numeric expression (TRUE if non-zero)
or a string expression (TRUE if non-null)
<LI>
<EM>opt_str</EM>
: a string argument which may or may not be
a string expression.
If it begins with a string literal, label or function it is treated
as a 
<EM>const_expr$</EM>
.
If it does not, it is accepted "as-is".
In particular, it is 
<EM>not</EM>
 subject to
<A HREF="#l25">escape processing</A>
<LI>
<EM>filename_str</EM>
: an 
<EM>opt_str</EM>
 representing a legal filename,
except that any enclosing left- and right-angle brackets are always
removed.
Drive and path information may be included; if it is not then the file
is assumed to be in the same location as the main source file specified
on the command line
_ 
<EM>hex_str</EM>
: an 
<EM>opt_str</EM>
 consisting only of hexadecimal character pairs,
except that Motorola, Intel or C-style radix indicator characters
may also be present
<LI>
<EM>text</EM>
: arbitrary text which is accepted "as-is" with no processing
<LI>
<EM>name</EM>
: an identifier which has the same form as a global label.
It must be specified literally
<LI>
<EM>name$</EM>
: an identifier which has the same form as a global label.
It may be specified either literally or as a string expression
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l7b">The Equality Idiom</A>
</BIG>
</STRONG>
</CENTER>
<P>
Several HXA pseudo ops accept or require
<EM>equality</EM>
 (or 
<EM>assignment</EM>
) arguments.
The general form of these arguments are 
<EM>opt_strs</EM>
 containing a single
un-escaped equals sign ('='):
<P>
<UL>
<LI>
<EM>left=right</EM>
</UL>
<P>
The meaning is that whatever appears on the right side
is assigned to whatever appears on the left side.
This is similar the normal right-to-left assignment of most high-level
languages.
<P>
The argument may or may not be a string expression.
If it begins with a string literal, label or function it is treated
as a 
<EM>const_expr$</EM>
.
Note the argument is twice subjected to
<A HREF="#l25">escape processing</A>
,
once when it is first evaluated and once again when it is
split at the equals sign.
<P>
If the argument is not a string expression it is accepted "as-is",
and is 
<EM>not</EM>
 subject to escape processing.
<P>
Equality arguments are similar in many ways to sub-fields
of the 
<A HREF="#l88">expression field</A>
, except that the separator character is an
equals sign instead of a comma.
In particular:
<P>
<UL>
<LI>
an 
<A HREF="#l25">unescaped</A>
equals sign outside of a literal string marks a split point
<LI>
leading and trailing whitespace is removed from each argument
<LI>
blank or empty arguments are not allowed
</UL>
<P>
A difference:
<P>
<UL>
<LI>
there must be exactly two arguments, 
<EM>left</EM>
 and 
<EM>right</EM>
. Fewer cause
an error, more are ignored
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l52">ASSERT</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>ASSERT</STRONG>
<EM>conditional_expr</EM>
</CODE>
<P>
"ASSERT" evaluates 
<EM>conditional_expr</EM>
 and issues an error message if the
result is FALSE, otherwise it is silent.
<P>
A failed assertion is reported as soon as it is known.
If 
<EM>conditional_expr</EM>
 cannot be resolved and checked during the first pass,
it will be during the second.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l5c">Assert Messages</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l53">ASSUME</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>ASSUME</STRONG>
<EM>opt_str [[, opt_str]..]</EM>
</CODE>
<P>
"ASSUME" primarily provides a method to control several optional HXA
settings.
In effect this mainly substitutes a proliferation of "ASSUME" control strings
for a proliferation of pseudo ops.
<P>
"ASSUME" controls some processor-independent HXA options:
<P>
<UL>
<LI>
<A HREF="hxa_ihex.htm">Intel Hex</A>
 output file options
<LI>
<A HREF="hxa_mhex.htm">Motorola SRecord</A>
 output file options
<LI>
<A HREF="#l08">octet extraction order</A>
 of numeric values during file output
</UL>
<P>
If "ASSUME" does not recognize an 
<EM>opt_str</EM>
 as one of these, it is passed
to the processor-specific portion of the HXA variant in use.
What effect, if any, a control string has is completely arbitrary.
There is no requirement that any string do anything, or that
unrecognized strings trigger an error.
<P>
The documention of each HXA variant lists recognized strings and
what they do.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l0e">ASSUME Strings</A>
<LI>
<A HREF="hxa_test.htm#l0b">ASSUME Non-Default Order</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l54">BIT--</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<EM>[label]</EM>
<STRONG>BIT--</STRONG>
<EM>num_expr [[, num_expr]..]</EM>
</CODE>
<P>
Variants
<UL>
<LI>
<STRONG>BIT08</STRONG>
<LI>
<STRONG>BIT16</STRONG>
; 
<STRONG>BIT16R</STRONG>
<LI>
<STRONG>BIT24</STRONG>
; 
<STRONG>BIT24R</STRONG>
<LI>
<STRONG>BIT32</STRONG>
; 
<STRONG>BIT32R</STRONG>
</UL>
<P>
The "BIT--" pseudo ops store part or all of 
<EM>num_expr</EM>
 into the object code.
<P>
<EM>Num_expr</EM>
 is a signed or unsigned 32-bit integer value.
<P>
"BIT08" stores the least significant 8 bits,
"BIT16-" the least significant 16 bits,
"BIT24-" the least significant 24 bits, and
"BIT32-" the entire 32 bits.
<P>
Bits not stored are ignored, so 
<EM>num_expr</EM>
 can have a value larger than
the storage space alloted will hold.
<P>
By default storage of multi-byte values is in native CPU order, either
least significant byte (LSB) first or most significant byte (MSB) first.
The "R" suffix reverses the native order of stored bytes, so "BIT32R" used
on an LSB first CPU will store the MSB first in the object code.
<P>
The "BIT--" pseudo ops require at least one numeric expression argument.
Each separate expression is treated a separate 32-bit value to be stored
according to the specific "BIT--" rules.
<P>
Note that some assemblers allow mixed string and numeric expressions
to follow "BYTE" (or equivalent) pseudo ops.
HXA does not permit this for "BIT--", but does for 
<A HREF="#l7a">"STRING"</A>
.
<P>
The available "BIT--" pseudo ops are affected by 
<A HREF="#l40">non-standard byte sizes</A>
.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l1b">Numeric Data Definition</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l55">BIT-- Aliases</A>
</BIG>
</STRONG>
</CENTER>
<P>
Variants
<UL>
<LI>
<STRONG>BYTE</STRONG>
; 
<STRONG>RBYTE</STRONG>
; 
<STRONG>SBYTE</STRONG>
; 
<STRONG>UBYTE</STRONG>
<LI>
<STRONG>WORD</STRONG>
; 
<STRONG>RWORD</STRONG>
; 
<STRONG>SWORD</STRONG>
; 
<STRONG>UWORD</STRONG>
<LI>
<STRONG>REVWORD</STRONG>
; 
<STRONG>RREVWORD</STRONG>
; 
<STRONG>SREVWORD</STRONG>
; 
<STRONG>UREVWORD</STRONG>
<LI>
<STRONG>LONG</STRONG>
; 
<STRONG>RLONG</STRONG>
; 
<STRONG>SLONG</STRONG>
; 
<STRONG>ULONG</STRONG>
<LI>
<STRONG>REVLONG</STRONG>
; 
<STRONG>RREVLONG</STRONG>
; 
<STRONG>SREVLONG</STRONG>
; 
<STRONG>UREVLONG</STRONG>
</UL>
<P>
There are built-in aliases for "-BIT--" pseudo ops.
<P>
<UL>
<LI>
"BYTE", "WORD" and "LONG" are aliases for 
<A HREF="#l54">"BIT--"</A>
<LI>
"RBYTE", "R-WORD" and "R-LONG" are aliases for 
<A HREF="#l74">"RBIT--"</A>
<LI>
"SBYTE", "S-WORD" and "S-LONG" are aliases for 
<A HREF="#l78">"SBIT--"</A>
<LI>
"UBYTE", "U-WORD" and "U-LONG" are aliases for 
<A HREF="#l7d">"UBIT--"</A>
</UL>
<P>
The "-REV-" aliases reverse the native order of stored bytes.
<P>
The available "-BIT--" aliases are affected by 
<A HREF="#l40">non-standard byte sizes</A>
.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l4d">--BYBLOCK</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>--BYBLOCK</STRONG>
<EM>[filename]</EM>
</CODE>
<P>
Variants
<UL>
<LI>
<STRONG>HEXBYBLOCK</STRONG>
<LI>
<STRONG>OBJBYBLOCK</STRONG>
<LI>
<STRONG>SRECBYBLOCK</STRONG>
</UL>
<P>
The "--BYBLOCK" pseudo ops cause HXA to produce a separate output file for
each contiguous group of data-containing
<A HREF="#l79">segments</A>
 of a segmented program.
They have no effect in monolithic programs.
<P>
Two data-containing segments are considered contiguous if they are
consecutively numbered and the ending address of the lesser is equal
to the starting address of the greater.
HXA continues outputting segments to the same file as long as each
successive segment is contiguous with its predecessor.
A non-contiguous successor causes HXA to close the current output file
and open a new one.
<P>
"HEXBYBLOCK" creates text files containing object code translations
of the source in 
<A HREF="hxa_ihex.htm">Intel Hexadecimal Object File</A>
 format.
The start address record (if any) is written in the last file output.
<P>
"OBJBYBLOCK" produces binary files containing object code translations
of the source in raw format (no additions or subtractions).
<P>
"SRECBYBLOCK" creates text files containing object code translations
of the source in 
<A HREF="hxa_mhex.htm">Motorola Hexadecimal Object File</A>
 format.
Every file has the required start address record, but only the last
file output can have a non-zero value (if any).
<P>
If no 
<EM>filename</EM>
 is provided, the "--BYBLOCK" pseudo ops create default
names based on the names of the first segment in each contiguous group
(which must respect operating system conventions).
They replace the filename extension (if any) with new extensions.
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Replacement Filename Extensions</CAPTION>
<TR ALIGN=CENTER>
<TD>
<STRONG>Pseudo Op</STRONG>
<TD>
<STRONG>Replacement</STRONG>
<TR ALIGN=CENTER>
<TD>
HEXBYBLOCK
<TD>
HEX
<TR ALIGN=CENTER>
<TD>
OBJBYBLOCK
<TD>
OBJ
<TR ALIGN=CENTER>
<TD>
SRECBYBLOCK
<TD>
S19|S28|S37
</TABLE>
<P>
If a 
<EM>filename</EM>
 is provided, it is interpreted as a 
<EM>filename template</EM>
.
The template is used to differentiate each output file by tagging it
with the number of its first segment.
<P>
The template must contain within it exactly one instance of a format
specification.
The format is a subset of the C/C++ language "printf()"
format specification.
<P>
The basic specification must be one of '%0d', '%0x' or '%0X',
allowing zero-filled decimal or hexadecimal numbering.
A single digit character from '1' to '9' is allowed immediately after
'%0' to specify a minimum field width.
The template cannot lead the name but can be the extension.
<P>
Examples of legal filename templates:
<UL>
<LI>
name%04x.s28
<LI>
put%03dout.obj
<LI>
hexfile.%03d
</UL>
<P>
An illegal filename template:
<UL>
<LI>
%0xfile.hex
</UL>
<P>
Segments are numbered according to the order in which they are first
encountered in the source code.
Segments numbers are reported in the segment map portion of a
<A HREF="#l50">list</A>
 file.
<P>
By default the "--BYBLOCK" pseudo ops place their output in the same
directory the first source file resides in.
By providing these pseudo ops with a path and filename, output files can
be placed in any directory with any name.
<P>
"--BYBLOCK" pseudo ops may appear any number of times in the source code.
However if any subsequent use specifies a different 
<EM>filename</EM>
 than
the first use, HXA issues a warning message and ignores the new filename.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#la3">Intel Hexfile Output (By Blocks, ".%03d" Template)</A>
<LI>
<A HREF="hxa_test.htm#lad">Motorola Hexfile Output (By Blocks, Default Names)</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l4e">--BYSEG</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>--BYSEG</STRONG>
<EM>[filename]</EM>
</CODE>
<P>
Variants
<UL>
<LI>
<STRONG>HEXBYSEG</STRONG>
<LI>
<STRONG>OBJBYSEG</STRONG>
<LI>
<STRONG>SRECBYSEG</STRONG>
</UL>
<P>
The "--BYSEG" pseudo ops cause HXA to produce a separate output file for each
data-containing 
<A HREF="#l79">segment</A>
 of a segmented program.
They have no effect in monolithic programs.
<P>
"HEXBYSEG" creates text files containing the object code translations
of the source in 
<A HREF="hxa_ihex.htm">Intel Hexadecimal Object File</A>
 format.
The start address record (if any) is written in the last file output.
<P>
"OBJBYSEG" produces binary files containing object code translations
of the source in raw format (no additions or subtractions).
<P>
"SRECBYSEG" creates text files containing object code translations
of the source in 
<A HREF="hxa_mhex.htm">Motorola Hexadecimal Object File</A>
 format.
Every file has the required start address record, but only the last
file output can have a non-zero value (if any).
<P>
If no 
<EM>filename</EM>
 is provided, the "--BYSEG" pseudo ops create default
names based on the names of each segment
(which must respect operating system conventions).
They replace the filename extension (if any) with new extensions.
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Replacement Filename Extensions</CAPTION>
<TR ALIGN=CENTER>
<TD>
<STRONG>Pseudo Op</STRONG>
<TD>
<STRONG>Replacement</STRONG>
<TR ALIGN=CENTER>
<TD>
HEXBYSEG
<TD>
HEX
<TR ALIGN=CENTER>
<TD>
OBJBYSEG
<TD>
OBJ
<TR ALIGN=CENTER>
<TD>
SRECBYSEG
<TD>
S19|S28|S37
</TABLE>
<P>
If a 
<EM>filename</EM>
 is provided, it is interpreted as a 
<EM>filename template</EM>
.
The template is used to differentiate each output file by tagging it
with its segment number.
<P>
The template must contain within it exactly one instance of a format
specification.
The format is a subset of the C/C++ language "printf()"
format specification.
<P>
The basic specification must be one of '%0d', '%0x' or '%0X',
allowing zero-filled decimal or hexadecimal numbering.
A single digit character from '1' to '9' is allowed immediately after
'%0' to specify a minimum field width.
The template cannot lead the name but can be the extension.
<P>
Examples of legal filename templates:
<UL>
<LI>
aname%0d.hex
<LI>
out%02xput.obj
<LI>
sfile.%03X
</UL>
<P>
An illegal filename template:
<UL>
<LI>
%04dname.s19
</UL>
<P>
Segments are numbered according to the order in which they are first
encountered in the source code.
Segments numbers are reported in the segment map portion of a
<A HREF="#l50">list</A>
 file.
<P>
By default the "--BYSEG" pseudo ops place their output in the same
directory the first source file resides in.
By providing these pseudo ops with a path and filename, output files can
be placed in any directory with any name.
<P>
"--BYSEG" pseudo ops may appear any number of times in the source code.
However if any subsequent use specifies a different 
<EM>filename</EM>
 than
the first use, HXA issues a warning message and ignores the new filename.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#la8">Intel Hexfile Output (By Segments, Default Names)</A>
<LI>
<A HREF="hxa_test.htm#laf">Motorola Hexfile Output (By Segments, "%02x." Template)</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l56">COMMON</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>COMMON</STRONG>
</CODE>
<P>
The "COMMON" pseudo op can be used in
<A HREF="#l79">segmented</A>
 programs to cause every fragment
of a particular segment to start (or end) at the same memory address.
That is, all the fragments of a common segment overlay each other.
The size of a common segment is the size of its largest fragment.
<P>
"COMMON" cannot be used in segments which contain data.
Use of "COMMON" implicitly flags a segment as
<A HREF="#l7f">"UNINITIALIZED"</A>
.
If "COMMON" can be used in a segment it can be used any number of times.
<P>
The "COMMON" pseudo op is designed to simplify management of "scratch"
memory in segmented source code.
A single memory block may be re-divided by the 
<A HREF="#l58">"DS"</A>
 pseudo op
as convenient.
That is, multiple temporary variables with names convenient for
whatever routine is using them can occupy the same space
(though of course not at the same time).
<P>
Common segments do not occupy any space in any output file.
While they have absolute start and end addresses and lengths, they do
not have any 
<A HREF="#l1c">offset</A>
 value.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#la2">Common Segments</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l57">CPU</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>CPU</STRONG>
<EM>opt_str</EM>
</CODE>
<P>
By default HXA does not recognize any particular microprocessor
instruction set.
"CPU" enables HXA to recognize the instruction set of a
specific microprocessor.
<P>
A CPU can specified at any point before the first time
the program counter is altered by the source code.
In particular, a CPU 
<EM>must</EM>
 be specified before the first 
<A HREF="#l6c">"ORG"</A>
pseudo op is encountered.
<P>
The "CPU" pseudo op can be used any number of times.
If any use after the first specifies a different CPU than the first,
HXA will issue a warning message and ignore it.
<P>
As currently implemented one or more CPU instruction sets are hard-coded
into different versions of HXA.
The specific name of an HXA executable indicates which CPU or related
CPUs it is meant for.
For example, 
<EM>HXA_T</EM>
 is meant for the imaginary "T_XX" processors used
to test all processor-independent portions of HXA.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l9b">Set CPU</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l58">DS</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<EM>[label]</EM>
<STRONG>DS</STRONG>
<EM>const_expr</EM>
</CODE>
<P>
The "DS" pseudo op adds 
<EM>const_expr</EM>
 to the program counter.
No object code is generated for any skipped address.
<P>
If the value of 
<EM>const_expr</EM>
 forces the program counter outside its
valid range a fatal error occurs.
<P>
In monolithic programs negative values of 
<EM>const_expr</EM>
 are allowed
and have the effect of decrementing the program counter,
but a warning is issued.
<P>
Although "DS" itself does not store data, its use can cause data to be stored
at non-consecutive addresses.
There is an overall limit of 1023 on the number of times such "address jumps"
are allowed in monolithic programs.
<P>
In 
<A HREF="#l79">segmented</A>
 programs negative values of
<EM>const_expr</EM>
 are a fatal error.
<P>
"DS" cannot be used in segments which contain data.
If a segment is not already flagged as &lt;UNINITIALIZED|"UNINITIALIZED"&gt;,
use of "DS" implicitly does so.
<P>
"DS" is especially convenient for allocating consecutive variables
which are left uninitialized at assembly time.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l84">Define Uninitialized Storage</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l59">ECHO</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>ECHO</STRONG>
<EM>[opt_str]</EM>
</CODE>
<P>
If 
<EM>opt_str</EM>
 is present, the "ECHO" pseudo op copies it to 
<EM>stdout</EM>
,
the standard output file.
If 
<EM>opt_str</EM>
 is not present, a blank line is output to 
<EM>stdout</EM>
.
<P>
If an 
<A HREF="#l50">error file</A>
 has been specified, the output of "ECHO" is
sent there as well.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l5e">User Messages</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l5a">END</A>
</BIG>
</STRONG>
</CENTER>
<P>
Monolithic Source
<P>
<CODE>
<EM>[label]</EM>
<STRONG>END</STRONG>
<EM>[num_expr</EM>
]
</CODE>
<P>
Segmented Source
<P>
<CODE>
<STRONG>END</STRONG>
<EM>[num_expr]</EM>
</CODE>
<P>
During its first pass HXA normally processes source code lines up through
the last line of the first file it encounters
(ie., the root source file named when HXA is invoked).
If there are no errors, HXA then begins subsequent processing.
<P>
The "END" pseudo op can be used to immediately terminate the
processing of any source file.
Every following line in that file is ignored.
<P>
A 
<EM>label</EM>
 may be used in the default monolithic source organization
and is assigned the current value of the program counter.
In 
<A HREF="#l79">segmented</A>
 source organization the program counter
is invalid outside any segment, hence no label may be used.
<P>
If 
<EM>num_expr</EM>
 follows an "END" in the root file, it is assumed to
represent a start address to be included in a hexadecimal output file.
Whether or not any such file has actually been specified, 
<EM>num_expr</EM>
 is
always evaluated and range-checked.
<P>
"END" issues warnings if:
<UL>
<LI>
the current source file is an include file
<LI>
a 
<EM>num_expr</EM>
 is used in an include file (it is ignored)
<LI>
it is used within an open conditional, expansion or segment block
(the open block(s) will also cause a fatal error shortly afterwards)
</UL>
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l82">Termination</A>
<LI>
<A HREF="hxa_test.htm#l2b">Early Read Termination</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l4f">--END</A>
</BIG>
</STRONG>
</CENTER>
<P>
Variants
<UL>
<LI>
<EM>[label]</EM>
<STRONG>ABSEND</STRONG>
<EM>const_expr</EM>
<LI>
<STRONG>RELEND</STRONG>
</UL>
<P>
The "--END" pseudo ops cause HXA to make
<A HREF="#l79">segments</A>
absolute based on their ending rather than starting addresses.
<P>
"ABSEND" makes a segment 
<EM>absolute end</EM>
, forcing it to end at
<EM>const_expr</EM>
.
Note the last actual byte of the segment will be placed
at 
<EM>const_expr - 1</EM>
.
That is, one byte 
<EM>before</EM>
 the address represented by 
<EM>const_expr</EM>
.
If 
<EM>label</EM>
 is present it is assigned the value of 
<EM>const_expr</EM>
.
The segment program counter is not changed.
<P>
"RELEND" makes a segment 
<EM>relative end</EM>
, forcing it to end at the
absolute start address of the following segment.
Note the last actual byte of the segment will have an address one
byte before the start address of that successor segment.
<P>
Any segment may be absolute end, but a relative end segment cannot
be the last segment nor may it immediately preceed a
<A HREF="#l76">relative origin</A>
 segment.
<P>
"ABSEND" and "RELEND" may only be used within a segment fragment.
They must be used before the segment program counter has
changed, but can be used any number of times after that.
The 
<EM>const_expr</EM>
 of "ABSEND" must have the same value each time.
<P>
Neither "ABSEND" nor "RELEND" can be used in any segment which already
has another type.
They cannot be 
<A HREF="#l6d">padded</A>
.
<P>
Addresses in "ABSEND" and "RELEND" segments are always relative during
the first pass.
The absolute addresses of the data they contain cannot be determined
until their final sizes are known.
Thus references to locations and labels within them are always
<A HREF="#l2a">forward references</A>
.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l9e">"ABSEND" and "RELEND" Pseudo Ops</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l5c">ERROR</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>ERROR</STRONG>
<EM>[opt_str]</EM>
</CODE>
<P>
The "ERROR" pseudo op enables programmer-triggered error messages.
<P>
These messages are the same in every respect as their internally
triggered equivalents.
They are sent to 
<EM>stdout</EM>
 and also to
to the 
<A HREF="#l50">error file</A>
 if one has been specified.
The "ERROR" pseudo op also contributes to the running total
of such messages necessary to halt assembly altogether.
<P>
The optional 
<EM>opt_str</EM>
 argument can be used to provide a more detailed
description of what triggered the message.
In particular, a string expression may be used to display the value(s) of
one or more labels at the point of the error.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=12%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l5d">Error Message Guidelines</A>
</BIG>
</STRONG>
</CENTER>
<P>
While there are no hard and fast rules as to which message type is
appropriate when, HXA itself generally uses these:
<P>
<UL>
<LI>
<A HREF="#l81">WARN</A>
 if a single line of source code can be assembled correctly
but contains a minor mistake of no consequence or is unusual enough
that a major mistake may be looming.
Warnings do not halt assembly unless the maximum
<A HREF="#l6a">warning count</A>
 is exceeded
<LI>
<STRONG>ERROR</STRONG>
 if a single line of source code cannot be assembled correctly
under any circumstances.
Assembly will halt at the end of the current pass or if the maximum
<A HREF="#l6a">error count</A>
 is exceeded, whichever occurs first
<LI>
<A HREF="#l5f">FATAL</A>
 if an error large enough to threaten the correct assembly
of more than one source line occurs.
Assembly halts immediately
</UL>
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l5e">User Messages</A>
<LI>
<A HREF="hxa_test.htm#l65">User Messages w/ String Expressions</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l5b">EQU</A>
</BIG>
</STRONG>
</CENTER>
<P>
Numeric Label
<P>
<CODE>
<EM>label</EM>
<STRONG>EQU</STRONG>
<EM>const_expr</EM>
</CODE>
<P>
String Label
<P>
<CODE>
<EM>label$</EM>
<STRONG>EQU</STRONG>
<EM>const_expr$</EM>
</CODE>
<P>
Variants
<UL>
<LI>
<STRONG>EQU</STRONG>
<EM>alias</EM>
<STRONG>=</STRONG>
</UL>
<P>
The "EQU" pseudo op examines the type of the label and evaluates an
expression matching that type.
The result is assigned to the label.
<P>
<A HREF="#l35">Global</A>
 and 
<A HREF="#l35">local</A>
 labels can be assigned the same
value any number of times.
Assignment of a different value to an existing label is not allowed unless
the label is 
<A HREF="#l35">variable</A>
.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l13">Assign Label Value</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l5e">EXIT--</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>EXIT</STRONG>
</CODE>
<P>
<CODE>
<STRONG>EXITIF</STRONG>
<EM>conditional_expr</EM>
</CODE>
<P>
The "EXIT" pseudo op unconditionally stops HXA from processing the
remainder of the closest enclosing 
<A HREF="#l68">macro</A>
,
<A HREF="#l77">repeat</A>
, or 
<A HREF="#l82">while</A>
 block expansion.
<P>
The "EXITIF" pseudo op is a conditional version of "EXIT".
It behaves as "EXIT" if 
<EM>conditional_expr</EM>
 is TRUE,
otherwise it is ignored and processing of the current block expansion
continues.
<P>
"EXIT" can also be made conditional by using it within a
<A HREF="#l63">conditional assembly block</A>
 which is itself
within the body of the currently expanded block.
<P>
Both "EXIT" and "EXITIF" are legal only within block expansions.
<P>
HXA always recognizes any label attached to the pseudo op marking the
end of the block whether or not processing of the block is stopped early.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l53">EXIT from Macro</A>
<LI>
<A HREF="hxa_test.htm#l97">EXIT from Repeat</A>
<LI>
<A HREF="hxa_test.htm#lc1">EXIT from While</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l5f">FATAL</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>FATAL</STRONG>
<EM>[opt_str]</EM>
</CODE>
<P>
The "FATAL" pseudo op enables programmer-triggered fatal error messages.
Assembly halts immediately.
<P>
These messages are the same in every respect as their internally
triggered equivalents.
They are sent to 
<EM>stdout</EM>
 and also to
to the 
<A HREF="#l50">error file</A>
 if one has been specified.
<P>
The optional 
<EM>opt_str</EM>
 argument can be used to provide a more detailed
description of what triggered the message.
In particular, a string expression may be used to display the value(s) of
one or more labels at the point of the error.
<P>
While there are no hard and fast rules as to which message type is
appropriate when, HXA itself generally uses these
<A HREF="#l5d">guidelines</A>
.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l5e">User Messages</A>
<LI>
<A HREF="hxa_test.htm#l65">User Messages w/ String Expressions</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l50">--FILE</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>--FILE</STRONG>
<EM>[filename]</EM>
</CODE>
<P>
Variants
<UL>
<LI>
<STRONG>ERRFILE</STRONG>
<LI>
<STRONG>HEXFILE</STRONG>
<LI>
<STRONG>LISTFILE</STRONG>
<LI>
<STRONG>OBJFILE</STRONG>
<LI>
<STRONG>SRECFILE</STRONG>
</UL>
<P>
By default HXA produces no output other than status and error messages,
which are sent only to 
<EM>stdout</EM>
.
The "--FILE" pseudo opcodes direct HXA to produce several kinds of
output files.
<P>
"ERRFILE" writes error messages to a text file in addition to 
<EM>stdout</EM>
.
This is particularly useful if there are so many error messages they
cause the screen to scroll.
<P>
"HEXFILE" creates a text file containing the complete object code translation
of the source in 
<A HREF="hxa_ihex.htm">Intel Hexadecimal Object File</A>
 format.
The file must be further processed by a loader program before it can be
executed.
<P>
"HEXFILE" is affected by 
<A HREF="#l40">non-standard byte sizes</A>
.
<P>
"LISTFILE" creates a text file containing both source code and
a text representation of the object code produced.
This pseudo op is useful for experimentation as well
as documentation purposes.
<P>
"OBJFILE" produces a binary file containing the complete object code
translation of the source in raw format (no additions or subtractions).
If the source code represents an executable image, the file will also
be executable.
<P>
"SRECFILE" creates a text file containing the complete object code translation
of the source in 
<A HREF="hxa_mhex.htm">Motorola Hexadecimal Object File</A>
 format.
The file must be further processed by a loader program before it can be
executed.
<P>
"SRECFILE" is affected by 
<A HREF="#l40">non-standard byte sizes</A>
.
<P>
If no 
<EM>filename</EM>
 is provided, the "--FILE" pseudo ops create a default name
based on the name of the first source file encountered.
They replace the filename extension (if any) with new extensions.
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Replacement Filename Extensions</CAPTION>
<TR ALIGN=CENTER>
<TD>
<STRONG>Pseudo Op</STRONG>
<TD>
<STRONG>Replacement</STRONG>
<TR ALIGN=CENTER>
<TD>
ERRFILE
<TD>
ERR
<TR ALIGN=CENTER>
<TD>
HEXFILE
<TD>
HEX
<TR ALIGN=CENTER>
<TD>
LISTFILE
<TD>
LST
<TR ALIGN=CENTER>
<TD>
OBJFILE
<TD>
OBJ
<TR ALIGN=CENTER>
<TD>
SRECFILE
<TD>
S19|S28|S37
</TABLE>
<P>
By default the "--FILE" pseudo ops place their output in the same
directory the first source file resides in.
By providing these pseudo ops with a path and filename, output files can
be placed in any directory with any name.
<P>
"--FILE" pseudo ops may appear any number of times in the source code.
However if any subsequent use specifies a different 
<EM>filename</EM>
 than
the first use, HXA issues a warning message and ignores the new filename.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l7d">Output Files</A>
<LI>
<A HREF="hxa_test.htm#l87">Program Listing</A>
<LI>
<A HREF="hxa_test.htm#l43">Intel Hexadecimal Object</A>
<LI>
<A HREF="hxa_test.htm#l67">Motorola SRecord Object</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l60">FILL</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<EM>[label]</EM>
<STRONG>FILL</STRONG>
<EM>const_expr [, hex_str ]</EM>
</CODE>
<P>
The "FILL" pseudo op inserts 
<EM>const_expr</EM>
 bytes into the object code.
<P>
<EM>Const_expr</EM>
 must have a value in the range one
to the maximum value of the program counter plus one.
Otherwise "FILL" is always ignored, and an error occurs if
<EM>const_expr</EM>
 is not zero.
<P>
By default "FILL" inserts zero bytes ($00) into the object code.
If the optional 
<EM>hex_str</EM>
 is supplied, its values are used instead.
Bytes are taken from 
<EM>hex_str</EM>
 in the same left-to-right
order they appear, regardless of CPU byte orientation.
<P>
"FILL" uses only as many bytes of 
<EM>hex_str</EM>
 as needed.
If more are needed than 
<EM>hex_str</EM>
 supplies, it is duplicated
as often as required.
<P>
"FILL" may be used in monolithic or segmented source whenever the
program counter is valid.
Filling appears in the object code starting at the current value
of the program counter.
<P>
Segments cannot be both filled and 
<A HREF="#l7f">uninitialized</A>
.
A fill which causes a segment program counter to exceed its range
is an error.
<P>
"FILL" is affected by 
<A HREF="#l40">non-standard byte sizes</A>
.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l85">Fill Block With Constant Data</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l61">HEX</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<EM>[label]</EM>
<STRONG>HEX</STRONG>
<EM>hex_str</EM>
 [[, hex_str]..]&gt;
</CODE>
<P>
The "HEX" pseudo op stores byte values specified by 
<EM>hex_str</EM>
into the object code.
Each 
<EM>hex_str</EM>
 must contain a even number of Ascii hexadecimal characters
(0-9A-Fa-f).
Each pair of characters is interpreted as one byte value to be stored.
<P>
Typically each 
<EM>hex_str</EM>
 is an "as-is" value, that is, no delimiters or
other string expression markers are used that force expression evaluation.
Thus the values to be stored can be determined by inspection.
However any string expression may be used, as long as the result contains
an even number of Ascii hexadecimal characters.
<P>
Although a 
<EM>hex_str</EM>
 may any length, using commas to separate multiple
<EM>hex_strs</EM>
 can make inspection easier.
<P>
"HEX" processes each 
<EM>hex_str</EM>
 from left-to-right, so byte values are
stored into the object code in the same order they appear in each
successive 
<EM>hex_str</EM>
.
<P>
Any 
<EM>hex_str</EM>
 may optionally contain a radix indicator, which are
the only non-hexdecimal characters allowed,
However "HEX" is intended mainly as a convenience for entering binary data
by eliminating that requirement.
<P>
"HEX" is affected by 
<A HREF="#l40">non-standard byte sizes</A>
.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l61">HEX</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l63">IF..ELSEIF..ELSE..ENDIF</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>IF</STRONG>
<EM>conditional_expr</EM>
</CODE>
<P>
<CODE>
<EM>[[source code]..]</EM>
</CODE>
<P>
<CODE>
[
<STRONG>ELSEIF</STRONG>
<EM>conditional_expr</EM>
]
</CODE>
<P>
<CODE>
<EM>[[source code]..]</EM>
</CODE>
<P>
<CODE>
[
<STRONG>ELSE</STRONG>
]
</CODE>
<P>
<CODE>
<EM>[[source code]..]</EM>
</CODE>
<P>
<CODE>
<STRONG>ENDIF</STRONG>
</CODE>
<P>
A 
<EM>conditional assembly block</EM>
 consists of an unnamed group of zero or more
source code lines delimited by a matched pair of "IF".."ENDIF" pseudo ops.
The grouped source lines are called the 
<EM>body</EM>
 of the
conditional assembly block.
<P>
Evaluation of the 
<EM>conditional_expr</EM>
 following the "IF" pseudo op controls
whether or not HXA processes the body of the conditional assembly block.
If it is TRUE, the body is processed.
If it is FALSE, the body is skipped.
<P>
The body of a conditional assembly block may be subdivided into 
<EM>branches</EM>
by using the optional "ELSEIF" and "ELSE" pseudo ops.
At most only one branch of a conditional assembly block is ever processed.
<P>
Any number of "ELSEIF" pseudo ops may be used in a
conditional assembly block to evaluate alternate conditions.
The 
<EM>conditional_expr</EM>
 following "ELSEIF" is evaluated only if no previous
branch has been processed, otherwise it and the entire branch are skipped.
If 
<EM>conditional_expr</EM>
 evaluates as true, the branch is processed and
any following branches are skipped.
<P>
The first "ELSE" pseudo op encountered allows processing of its branch
only if no previous branch has been processed.
After the first "ELSE" at least one branch has always been processed,
so any following branches are always skipped
Thus there is usually at most one "ELSE" controlling only the last
branch of a conditional block.
<P>
Conditional assembly blocks may be nested to any depth by directly nesting
"IF".."ENDIF" pairs.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l04">Conditional Assembly</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l64">INCBIN</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>INCBIN</STRONG>
<EM>filename_str [[,const_expr1] , const_expr2]</EM>
</CODE>
<P>
The "INCBIN" pseudo op causes HXA to begin reading raw data
from 
<EM>filename_str</EM>
, which is assumed to contain arbitrary binary data
to be stored directly into the object code without any processing.
<P>
By default HXA reads all of 
<EM>filename_str</EM>
 into the object code.
If 
<EM>const_expr1</EM>
 is specified and is a positive integer,
it represents the maximum number of bytes to read.
Reading stops when 
<EM>const_expr1</EM>
 bytes have been read or the end of file
is reached, whichever occurs first.
If 
<EM>const_expr1</EM>
 is less than one, the entire file is read.
<P>
By default HXA begins reading at the start of 
<EM>filename_str</EM>
,
which is at byte offset zero.
If 
<EM>const_expr2</EM>
 is specified and is a positive integer, reading begins
at byte offset 
<EM>const_expr2</EM>
, which is byte 
<EM>const_expr2 + 1</EM>
 of the file.
Reading continues until 
<EM>const_expr1</EM>
 bytes have been read or the end
of the file is reached, whichever occurs first.
If 
<EM>startpos</EM>
 is less than one reading begins at the start of 
<EM>filename_str</EM>
.
<P>
Note that 
<EM>const_expr2</EM>
 cannot be specified unless 
<EM>const_expr1</EM>
has been also.
However 
<EM>const_expr1</EM>
 can be a negative value, which effectively forces
the entire remainder of the file to be read.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l03">Binary Inclusion</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l62">IF--DEF</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>IF--DEF</STRONG>
<EM>name$</EM>
</CODE>
<P>
Variants
<UL>
<LI>
<STRONG>IFDEF</STRONG>
<LI>
<STRONG>IFNDEF</STRONG>
</UL>
<P>
"IFDEF" and "IFNDEF" may be used instead of an
<A HREF="#l63">IF</A>
 pseudo opcode to begin any
<EM>conditional assembly block</EM>
.
They test whether or not the global numeric label 
<EM>name$</EM>
 is present
in the symbol table.
"IFDEF" is TRUE only if 
<EM>name$</EM>
 is present.
"IFNDEF" is TRUE only if 
<EM>name$</EM>
 is 
<EM>not</EM>
 present.
<P>
Note that only the existence of 
<EM>name$</EM>
, not its value, is important
in this context.
<P>
All variants of HXA support one or more 
<A HREF="#l3a">predefined labels</A>
which can be used with these pseudo ops.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l08">IFDEF and IFNDEF Blocks</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l65">INCLUDE</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>INCLUDE</STRONG>
<EM>filename_str</EM>
</CODE>
<P>
The "INCLUDE" pseudo op causes HXA to begin reading source code lines
from 
<EM>filename_str</EM>
, which is assumed to be a text file containing
assembly language source code.
When all lines of 
<EM>filename_str</EM>
 have been read, HXA resumes reading
input lines from the file that contained the "INCLUDE".
<P>
"INCLUDE" may not be used within a macro, repeat or while expansion.
<P>
An included file has its own local scope.
<A HREF="#l35">Local</A>
 labels in an include file will not conflict
with labels of the same name in other source files.
<P>
File inclusion may be nested to any depth by using the "INCLUDE" pseudo op
within an included file.
<P>
Because HXA accepts only one filename on its command line, multiple source
files can be assembled together only by using this pseudo op within that
file.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l2e">Inclusion</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l66">LINESPACE</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>LINESPACE</STRONG>
<EM>const_expr</EM>
</CODE>
<P>
The "LINESPACE" pseudo op sets the number of page lines each printed line
in a 
<A HREF="#l50">listfile</A>
 uses.
For each line listed on a page, "LINESPACE" minus one blank lines
are also printed.
<P>
The default and minimum "LINESPACE" value is one.
There are no blank lines between listing lines.
<P>
The maximum allowed value is the maximum 
<A HREF="#l6f">page length</A>
 minus one.
This is not the same as the actual page length.
In particular, "LINESPACE" may have a value greater than the actual page
length.
This results in only one line printed on each listfile page.
<P>
"LINESPACE" may be used as many times as desired, but must have the same
value each time.
Use of an illegal value causes an error and line spacing retains
its current value.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l8a">Change Line Spacing</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l67">LIST--</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>LIST--</STRONG>
<EM>[flagname] [[,flagname]..]</EM>
</CODE>
<P>
Variants
<UL>
<LI>
<STRONG>LISTON</STRONG>
<LI>
<STRONG>LISTOFF</STRONG>
</UL>
<P>
The "LIST--" pseudo ops enable or disable various listing options
used by HXA to create a 
<A HREF="#l50">listfile</A>
.
They also influence which source lines HXA saves during the first pass,
which is done in order to create a listfile without re-reading and
re-processing the entire source.
<P>
"LIST--" pseudo ops can appear any number of times in the source code
file(s).
Note that when a listing begins, the listing flags are in the state
set by their last use in the source code.
<P>
A listing file has up to five major sections: 
<EM>object</EM>
, 
<EM>labels</EM>
,
<EM>cross-refernce</EM>
, 
<EM>segments</EM>
 and 
<EM>statistics</EM>
.
<P>
<STRONG>Object Section</STRONG>
<P>
The 
<EM>object</EM>
 section lists all or part of the source code together
with a text representation of the object code produced.
The OBJECT flag controls both whether or not there is an object section
at all and, if there is, whether or not particular portions of the source
are listed.
<P>
The default state of the OBJECT flag is ON.
In this state there is an object section, and every source and expansion
line which results in object code is listed regardless of the state of any
lower-priority object listing flag.
<P>
If the OBJECT flag is turned OFF at any point in the source code,
there will be no object listing from that point until it is turned ON again.
<P>
If the OBJECT flag is OFF at the end of assembly there will be no
object section listing at all.
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Object Listing Control Flags (In order of priority)</CAPTION>
<TR ALIGN=CENTER>
<TD>
<STRONG>Flag Name</STRONG>
<TD>
<STRONG>Lists</STRONG>
<TD>
<STRONG>Default State</STRONG>
<TR ALIGN=CENTER>
<TD>
OBJECT
<TD>
Source lines which produce object code
<TD>
ON
<TR ALIGN=CENTER>
<TD>
SOURCE
<TD>
Source lines which do not produce object code
<TD>
ON
<TR ALIGN=CENTER>
<TD>
INCLUDES
<TD>
Contents of "INCLUDE" files
<TD>
ON
<TR ALIGN=CENTER>
<TD>
MACROS
<TD>
Macro expansions
<TD>
OFF
<TR ALIGN=CENTER>
<TD>
UNTAKEN
<TD>
Untaken conditional branches
<TD>
OFF
<TR ALIGN=CENTER>
<TD>
ALLEQU
<TD>
Non-global EQU values
<TD>
OFF
</TABLE>
<P>
Notes
<UL>
<LI>
an object flag of higher priority overrides one of lower
priority in the listing
<LI>
the state of the object flags can be changed any number
of times by "LIST--" pseudo ops in the source code, so some sections
may be listed in more or less detail as desired
<LI>
a "LIST--" pseudo op with no flags specified defaults to setting
the OBJECT flag
<LI>
ALLEQU is not actually a priority flag, and only controls whether
or not the values of equates to non-global labels are displayed
<LI>
in the default setting HXA saves all source lines read directly from
files, but saves expansion lines only if they generate code or data
(since they will not be listed otherwise).
This setting normally allows HXA to process larger volumes of source
code.
In general the listing of macro expansions and untaken conditional branches
might best be limited to their development and testing, and left turned off
after that
</UL>
<P>
Source code lines are tagged with a prefix character indicating where
they came from:
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Origin of Source Code Line</CAPTION>
<TR ALIGN=CENTER>
<TD>
<STRONG>Prefix</STRONG>
<TD>
<STRONG>From</STRONG>
<TR ALIGN=CENTER>
<TD>
' '
<TD>
root source file
<TR ALIGN=CENTER>
<TD>
'+'
<TD>
included source file
<TR ALIGN=CENTER>
<TD>
'^'
<TD>
macro expansion in root file
<TR ALIGN=CENTER>
<TD>
'&gt;'
<TD>
macro expansion in included file
</TABLE>
<P>
Many pseudo ops are displayed with associated addresses and values:
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Addresses and Values</CAPTION>
<TR ALIGN=CENTER>
<TD>
<STRONG>Pseudo Op</STRONG>
<TD>
<STRONG>Address</STRONG>
<TD>
<STRONG>Value</STRONG>
<TR ALIGN=CENTER>
<TD>
ABSEND
<TD>
Always Zero
<TD>
End Address
<TR ALIGN=CENTER>
<TD>
ASSERT
<TD>
Always Zero
<TD>
Always One
<TR ALIGN=CENTER>
<TD>
-BIT--
<TD>
Program Counter
<TD>
1 to 4 bytes
<TR ALIGN=CENTER>
<TD>
DS
<TD>
Program Counter
<TD>
Length
<TR ALIGN=CENTER>
<TD>
END
<TD>
Program Counter
<TD>
1 zero byte (monolithic w/o start)
<TR ALIGN=CENTER>
<TD>
END
<TD>
Program Counter
<TD>
Start Address (monolithic w/ start)
<TR ALIGN=CENTER>
<TD>
END
<TD>
Always Zero
<TD>
Start Address (segmented w/ start)
<TR ALIGN=CENTER>
<TD>
EQU
<TD>
Always Zero
<TD>
4 bytes (numeric)
<TR ALIGN=CENTER>
<TD>
EQU
<TD>
Always Zero
<TD>
1 to 4 bytes (string)
<TR ALIGN=CENTER>
<TD>
ORG
<TD>
Org Address
<TD>
Org Address
<TR ALIGN=CENTER>
<TD>
ORG
<TD>
Always Zero
<TD>
Org Address (segmented
<TD>
second+ use)
</TABLE>
<P>
Notes
<UL>
<LI>
"bytes" refers to 8-bit octets
<LI>
null strings are displayed as a single zero byte
<LI>
only the -BIT-- pseudo ops actually create object code
<LI>
if ALLEQU is ON, expansions of 
<A HREF="#l68">macros</A>
 with one
or more formal arguments which are local and variable labels will show
the results of assignments to them in the listing
</UL>
<P>
<STRONG>Labels Section</STRONG>
<P>
The 
<EM>labels</EM>
 section lists some or all of the symbols defined during
assembly.
The state of the LABELS flag controls whether or not a labels section
is produced.
If the LABELS flag is OFF when assembly ends, then no labels section
is produced.
<P>
If the LABELS flag is ON when assembly ends (the default), then
four groups of names are listed in the following order:
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<TR ALIGN=CENTER>
<TD>
<STRONG>Symbol Names</STRONG>
<TD>
<STRONG>Ordering</STRONG>
<TR ALIGN=CENTER>
<TD>
Numeric Global and Variable
<TD>
Alphabetic
<TR ALIGN=CENTER>
<TD>
Numeric Global and Auto
<TD>
Numeric
<TR ALIGN=CENTER>
<TD>
String Global, Variable and Auto
<TD>
Alphabetic
<TR ALIGN=CENTER>
<TD>
Macro
<TD>
Alphabetic
</TABLE>
<P>
All names are listed together with a count of how often they were referred
to and their final value (if applicable).
<P>
"Auto" labels appear only if the AUTOS flag is ON.
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Label Listing Control Flags</CAPTION>
<TR ALIGN=CENTER>
<TD>
<STRONG>Flag Name</STRONG>
<TD>
<STRONG>Lists</STRONG>
<TD>
<STRONG>Default State</STRONG>
<TR ALIGN=CENTER>
<TD>
LABELS
<TD>
Global and variable labels and macro names
<TD>
ON
<TR ALIGN=CENTER>
<TD>
AUTOS
<TD>
Internal form of local and branch target labels
<TD>
OFF
</TABLE>
<P>
<STRONG>Cross-Reference Section</STRONG>
<P>
The 
<EM>cross-reference</EM>
 section lists events, line numbers
and source files related to global labels and macro names.
<P>
The XREF flag controls whether or not a cross-reference section is
produced.
If it is OFF (the default), no cross-reference section will appear.
The XREF flag may be turned ON and OFF as often as desired.
Whenever it is ON, data is collected that is used to create this section.
<P>
Each global numeric label, global string label and macro name referenced
while the XREF flag is ON has its own sub-section in the cross-reference
section.
<P>
The first line of a sub-section lists the name and the number of times
it was referenced.
This is followed by detail lines for each of those references showing:
<P>
<UL>
<LI>
the line number of the reference in the listing file
<LI>
the event type (label lookup, macro definition or expansion, etc)
<LI>
the line number of the reference in its source file
<LI>
the source file name
</UL>
<P>
Notes
<UL>
<LI>
the listing line number will appear only if there 
<EM>is</EM>
 a listing line
number, ie., the LINENUMS flag is ON at the end of assembly (not the default)
<LI>
the source file name does not appear for references in the root file (the
one named on the command line), but only for references in included files
<LI>
groups of identical detail lines may be reported as one detail line
followed by a line indicating how many times it repeats
</UL>
<P>
<STRONG>Segments Section</STRONG>
<P>
The 
<EM>segments</EM>
 section can appear only if a
<A HREF="#l79">segmented</A>
 source program is used.
It lists the named segments in the order they appear in the object code,
together with their type, start and end addresses, sizes
and padding (if any).
<P>
The state of the SEGMENTS flag controls whether or not a segment map
is produced for a segmented program.
If it is ON (the default) the map is produced.
<P>
<STRONG>Statistics Section</STRONG>
<P>
The 
<EM>statistics</EM>
 section lists miscellaneous data concerning the current
assembly.
The state of the STATS flag controls whether or not a statistics section
is produced.
If the STATS flag is OFF when assembly ends (the default),
then no statistics section is produced.
<P>
If the STATS flag is ON when assembly ends, HXA currently reports:
<P>
<UL>
<LI>
the number and type (eg., macro expansion) of source lines assembled
<LI>
the time taken to read the source lines (pass one)
<LI>
the lines per second
<LI>
the number of 32-bit data values created during the first pass
<LI>
the time taken to resolve any forward references in and range check the
data values (pass two)
<LI>
the resolutions per second
<LI>
the total time taken for both passes
<LI>
the object code size
<LI>
the counts of items stored and hits for several internal caches
</UL>
<P>
<STRONG>Global Flags</STRONG>
<P>
Global flags affect all other flags and/or sections.
<P>
The ALL flag sets every other flag to ON or OFF, depending
on which pseudo op it follows.
<P>
The LINEWRAP flag is ON by default.
Text which exceeds the allowed line width is "wrapped" to
successive lines as often as needed until completely printed.
If this flag is OFF at the end of assembly, text which exceeds one line
is truncated at the end of the first line.
<P>
The LINENUMS flag is OFF by default.
If it is ON at the end of assembly, every line of any listing
is consecutively numbered at its start.
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Global Flags</CAPTION>
<TR ALIGN=CENTER>
<TD>
<STRONG>Flag Name</STRONG>
<TD>
<STRONG>Affects</STRONG>
<TD>
<STRONG>Default State</STRONG>
<TR ALIGN=CENTER>
<TD>
ALL
<TD>
every other flag
<TD>
N/A
<TR ALIGN=CENTER>
<TD>
LINEWRAP
<TD>
line wrapping
<TD>
ON
<TR ALIGN=CENTER>
<TD>
LINENUMS
<TD>
line numbers
<TD>
OFF
</TABLE>
<P>
<STRONG>Alphabetical Ordering of Listing Control Flags</STRONG>
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<TR ALIGN=CENTER>
<TD>
<STRONG>Name</STRONG>
<TD>
<STRONG>Section</STRONG>
<TD>
<STRONG>Type</STRONG>
<TD>
<STRONG>Default State</STRONG>
<TR ALIGN=CENTER>
<TD>
ALL
<TD>
N/A
<TD>
Global
<TD>
N/A
<TR ALIGN=CENTER>
<TD>
AUTOS
<TD>
Labels
<TD>
Secondary
<TD>
OFF
<TR ALIGN=CENTER>
<TD>
INCLUDES
<TD>
Object
<TD>
Secondary
<TD>
ON
<TR ALIGN=CENTER>
<TD>
LABELS
<TD>
Labels
<TD>
Master
<TD>
ON
<TR ALIGN=CENTER>
<TD>
LINENUMS
<TD>
All
<TD>
Global
<TD>
OFF
<TR ALIGN=CENTER>
<TD>
LINEWRAP
<TD>
All
<TD>
Global
<TD>
ON
<TR ALIGN=CENTER>
<TD>
MACROS
<TD>
Object
<TD>
Secondary
<TD>
OFF
<TR ALIGN=CENTER>
<TD>
OBJECT
<TD>
Object
<TD>
Master
<TD>
ON
<TR ALIGN=CENTER>
<TD>
SOURCE
<TD>
Object
<TD>
Secondary
<TD>
ON
<TR ALIGN=CENTER>
<TD>
STATS
<TD>
Statistics
<TD>
Master
<TD>
OFF
<TR ALIGN=CENTER>
<TD>
UNTAKEN
<TD>
Object
<TD>
Secondary
<TD>
OFF
<TR ALIGN=CENTER>
<TD>
XREF
<TD>
Cross-Reference
<TD>
Master
<TD>
OFF
</TABLE>
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l8e">Listing</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l68">MACRO..ENDMACRO</A>
</BIG>
</STRONG>
</CENTER>
<P>
Preferred Useage
<P>
<CODE>
<STRONG>MACRO</STRONG>
<EM>name$</EM>
<EM>[[, ?arg[=default]]..]</EM>
</CODE>
<P>
<CODE>
<EM>[[source code]..]</EM>
</CODE>
<P>
<CODE>
<EM>[label]</EM>
<STRONG>ENDMACRO</STRONG>
<EM>[name$]</EM>
</CODE>
<P>
Alternate Useage
<P>
<CODE>
<EM>name</EM>
<STRONG>MACRO</STRONG>
<EM>[?arg[=default] [[, ?arg[=default]]..]]</EM>
</CODE>
<P>
<CODE>
<EM>[[source code]..]</EM>
</CODE>
<P>
<CODE>
<EM>[label]</EM>
<STRONG>ENDMACRO</STRONG>
</CODE>
<P>
Variants
<UL>
<LI>
<STRONG>MACRO</STRONG>
<EM>alias</EM>
<STRONG>MAC</STRONG>
<LI>
<STRONG>ENDMACRO</STRONG>
<EM>alias</EM>
<STRONG>ENDM</STRONG>
</UL>
<P>
A 
<EM>macro</EM>
 consists of a named group of zero or more source code lines
delimited by a matched pair of "MACRO".."ENDMACRO" pseudo ops.
The grouped source lines are called the 
<EM>body</EM>
 of the macro.
<P>
A "MACRO".."ENDMACRO" pair is used to 
<EM>define</EM>
 a macro.
Once a macro has been defined, use of its name in the opcode field
of a source code line causes macro 
<EM>expansion</EM>
.
This has the effect of inserting the body of the macro into the source
code at that point.
<P>
The preferred form of macro definition permits string expressions to
denote 
<EM>name$</EM>
, but the alternate form requires a literal 
<EM>name</EM>
.
Macro names must be unique.
No two macros can have the same name at the same time, nor can a
macro have the same name as an existing label or opcode.
<P>
Note that if "ENDMACRO" is labeled, the label is considered to be
within the body of the macro.
It is duplicated each time the macro is expanded, hence
<A HREF="#l35">global</A>
 labels are discouraged here.
<P>
If "ENDMACRO" is followed by a 
<EM>name$</EM>
, it must match the 
<EM>name$</EM>
of the "MACRO" it is paired with.
<P>
Macros are an advanced assembler function.
They are not necessary, but whenever a programmer uses similar
sequences of source code in different places, macros can help make
that code clear, correct and compact.
<P>
<STRONG>Macro Arguments</STRONG>
<P>
Macros can optionally be (and usually are) defined to accept 
<EM>arguments</EM>
.
Arguments "customize" a macro by allowing its body to be altered
each time it is expanded.
<P>
There are two kinds of arguments, 
<EM>formal</EM>
 and 
<EM>actual</EM>
.
Both kinds appear in the expression field following a macro name.
If a macro has more than one argument, they are separated by commas.
<P>
Formal arguments are used during macro definition.
Formal text arguments names have the same form as
<A HREF="#l37">global labels</A>
,
except their type is indicated by an initial question mark ('?') character.
Within the body of the macro, formal arguments may be freely used
in the expression field of any source line.
To use formal arguments in the label or opcode fields, the
<A HREF="#l73">"PUTBACK"</A>
 pseudo op must be employed.
<P>
Actual arguments are used during macro expansion.
The first actual argument 
<EM>text</EM>
 will replace the first formal argument
<EM>name</EM>
 wherever it appears in the macro body (
<EM>including</EM>
 within quoted
string literals), the second actual will replace the second formal,
and so on.
<P>
Replacement is performed as a straight text substitution.
There is no other interpretation or understanding of the arguments.
In particular,
<A HREF="#l25">escape sequences</A>
in actual arguments are not processed until the expanded line is assembled.
<P>
The number of actual arguments provided to a macro expansion must always
match the number of formal arguments declared during macro definition.
<P>
<STRONG>Default Actual Arguments</STRONG>
<P>
A 
<EM>default</EM>
 actual argument is declared during macro definition
using 
<A HREF="#l7b">the equality idiom</A>
 (except only literal values, not string
expressions, are recognized here):
<P>
<UL>
<LI>
<EM>?formalarg</EM>
<STRONG>=</STRONG>
<EM>text</EM>
</UL>
<P>
During macro expansions default actual arguments will be substituted for
any formal arguments which have them and for which no other actual argument
has been provided.
<P>
Note that because blank sub-fields are not allowed in the expression field
it is not possible to skip over default actual arguments.
Thus,
<P>
<UL>
<LI>
during definition, if a default actual argument is declared for
any formal argument, every formal argument declared after it must also
have a default actual argument
<LI>
during expansion, if a default actual argument is substituted for
any formal argument, every formal argument declared after it will also
substitute its default argument
</UL>
<P>
<STRONG>Variable and Local Label Formal Arguments</STRONG>
<P>
In addition to text formal arguments, variable and local labels may
be used as formal arguments in macro definitions.
Like text formal arguments, variable and local label formal arguments
may have default actual arguments.
<P>
At the start of each macro expansion the actual argument of each
variable or local formal argument is treated as an expression.
It is evaluated and the result assigned to the corresponding variable
or local formal argument.
<P>
This is equivalent in every way to an 
<A HREF="#l5b">"EQU"</A>
 pseudo opcode
within the body of a macro using a variable or local label on
the left-hand side and a formal text argument on the right.
It is essentially a short-hand method of accomplishing the same task.
<P>
At expansion time variable and local labels used as formal arguments are
assigned actual argument evaluation results in the same left-to-right order
they appear in the macro definition.
<P>
Thus this form of definition:
<P>
MACRO mymacro, ?myarg1, ?myarg2, ?myarg3
]myvar1     EQU ?myarg1
@myvar2     EQU ?myarg2
]myvar3$    EQU ?myarg3
<P>
ENDMACRO
<P>
and this form:
<P>
MACRO mymacro, ]myvar1, @myvar2, ]myvar3$
<P>
ENDMACRO
<P>
are completely equivalent.
<P>
If the listing flag 
<A HREF="#l67">ALLEQU</A>
 is ON, expansions of macros with one
or more formal arguments which are local and variable labels will show
the results of assignments to them in the listing.
<P>
<STRONG>Macros and Local Scopes</STRONG>
<P>
Every macro expansion causes a nested local scope to be created
without ending the existing one.
<A HREF="#l38">Local labels</A>
 with the same name as others outside the
new local scope do not conflict with those names.
Local scopes can be nested to any depth by nesting macro expansions.
As each expansion ends, so does the nested local scope it created.
<P>
<STRONG>Macro Nesting</STRONG>
<P>
Macro definitions can be nested in two different ways.
First, "MACRO".."ENDMACRO" pairs may be directly nested during definition.
Second, a macro body may contain the name of another macro to be expanded.
<P>
Note that these two forms have slightly different expansion behavior.
When expanding an outer definition of the first form, the delimiters of
any inner definition are simply ignored
(note this same principle prevents a macro definition from being recognized
within 
<A HREF="#l77">repeat</A>
 and 
<A HREF="#l82">while</A>
 blocks).
Because only one macro definition is expanded, only one new local scope
is created.
<P>
Expanding the second form causes a new local scope to be
created for each macro expansion invoked.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l4f">Macros</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l69">MARGINS</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>MARGINS</STRONG>
<EM>const_expr1, const_expr2</EM>
<EM>[, const_expr3, const_expr4]</EM>
</CODE>
<P>
The "MARGINS" pseudo op sets the top, right, bottom and left margins
(in that order) of each page in a 
<A HREF="#l50">listfile</A>
.
<P>
Margins are the number of lines (top and bottom) or character positions
(left and right) that are skipped at each page edge
without being printed to.
The default value of each margin is zero, meaning that lines and characters
are printed flush with each page edge.
This is suitable for "printing" to files meant to be loaded into a text
editor, but may not be in other circumstances.
<P>
The pair 
<EM>const_expr1, const_expr2</EM>
 sets the top and left margins,
respectively.
The optional pair 
<EM>const_expr3, const_expr4</EM>
 sets the bottom and right
margins, respectively.
<P>
The top and bottom margins combined must be less than the page length.
The left and right margins combined must be less than the page width
minus the minimum allowed width.
It may be helpful to use the 
<A HREF="#l6f">"PAGESIZE"</A>
 pseudo op before
"MARGINS".
<P>
"MARGINS" may be used as many times as desired, but must have the same
values each time.
Use of an illegal value causes an error and the affected parameter retains
its current value.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l93">Pagination</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l6a">MAX--</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>MAX--</STRONG>
<EM>const_expr</EM>
</CODE>
<P>
Variants
<UL>
<LI>
<STRONG>MAXDEPTH</STRONG>
<LI>
<STRONG>MAXERR</STRONG>
<LI>
<STRONG>MAXPUTBACK</STRONG>
<LI>
<STRONG>MAXSTACK</STRONG>
<LI>
<STRONG>MAXWARN</STRONG>
</UL>
<P>
The "MAX--" pseudo ops set limiting values on various internal counters.
If a limit is exceeded assembly halts.
<P>
<EM>Const_expr</EM>
 can be any value, although negative values generate a warning
and will cause assembly to stop the first time the limit is tested.
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Limit Controls</CAPTION>
<TR ALIGN=CENTER>
<TD>
<STRONG>Name</STRONG>
<TD>
<STRONG>Limits</STRONG>
<TD>
<STRONG>Default Maximum</STRONG>
<TR ALIGN=CENTER>
<TD>
MAXDEPTH
<TD>
Local Scope Nesting Depth
<TD>
128
<TR ALIGN=CENTER>
<TD>
MAXERR
<TD>
Error Messages Reported
<TD>
25
<TR ALIGN=CENTER>
<TD>
MAXPUTBACK
<TD>
Consecutive "PUTBACK" Lines
<TD>
128
<TR ALIGN=CENTER>
<TD>
MAXSTACK
<TD>
User stack depth
<TD>
128
<TR ALIGN=CENTER>
<TD>
MAXWARN
<TD>
Warning Messages Reported
<TD>
50
</TABLE>
<P>
HXA automatically opens a new nested local label scope in many circumstances,
such as block expansion or file inclusion.
"MAXDEPTH" controls the maximum number of nested scopes that may be open at
one time.
<P>
"MAXERROR" and "MAXWARN" respectively set the maximum number of error and
warning messages HXA will report before halting assembly altogether.
<P>
The 
<A HREF="#l73">"PUTBACKS"</A>
 pseudo op is capable of inserting a copy of
itself and its arguments into the input stream, leading to an infinite loop.
"MAXPUTBACK" guards against this possibility while allowing the limit
to be changed if it proves an obstacle.
<P>
"MAXSTACK" controls the number of items that may be pushed onto the user
stack at any one time.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l4e">Nesting Depth</A>
<LI>
<A HREF="hxa_test.htm#l5d">Error Count</A>
<LI>
<A HREF="hxa_test.htm#l5a">Putbacks Pseudo Op</A>
<LI>
<A HREF="hxa_test.htm#l5f">Warn Count</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l6b">MESGTEXT</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>MESGTEXT</STRONG>
<EM>ndx=mesg</EM>
<EM>[[, ndx=mesg]..]</EM>
</CODE>
<P>
All HXA-originated messages displayed to the user are created
based on an index into a table of 
<A HREF="hxa_mesg.htm#l01">assembler message texts</A>
.
<P>
The "MESGTEXT" pseudo op assigns arbitrary text to an index
using 
<A HREF="#l7b">the equality idiom</A>
.
HXA's default messages can thus be replaced by user-chosen messages.
<P>
<EM>Ndx</EM>
 must match an internal HXA message index exactly
(ie., the match is case-sensitive).
<P>
All characters in 
<EM>mesg</EM>
 outside the range $20-$7E are converted to a
printable hexadecimal representation before assignment to 
<EM>ndx</EM>
.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l0d">Assembler Messages</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l6c">ORG</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<EM>[label]</EM>
<STRONG>ORG</STRONG>
<EM>const_expr</EM>
</CODE>
<P>
Variants
<UL>
<LI>
<STRONG>ORG</STRONG>
<EM>alias</EM>
<STRONG>ABSORG</STRONG>
<LI>
<STRONG>ORG</STRONG>
<EM>alias</EM>
<STRONG>*=</STRONG>
<LI>
<STRONG>ORG</STRONG>
<EM>alias</EM>
<STRONG>$=</STRONG>
</UL>
<P>
The "ORG" pseudo op evaluates 
<EM>const_expr</EM>
 and assigns the result to the
<EM>program counter</EM>
 and, if present, to 
<EM>label</EM>
.
<P>
Depending on how and where it is used "ORG" also helps determine whether
a source program is organized as monolithic or
<A HREF="#l79">segmented</A>
.
<P>
HXA uses the program counter to determine address information for
assembled code and data.
Every source code line that generates code or data automatically updates
the value of the program counter by the size of that code or data.
<P>
The program counter has no default value.
It must be explicitly set by using an "ORG" pseudo op anywhere before the
first code- or data-generating source line is encountered.
<P>
Every time the value of the program counter changes, it is checked
against the legal range of values it may assume for the current 
<A HREF="#l57">CPU</A>
.
Any attempt to generate code or data outside the legal range causes an error.
There is no "wrapping" of program counter values from highest to lowest
addresses or vice versa.
<P>
Note that because "ORG" itself changes the value of the program counter,
the current 
<A HREF="#l57">CPU</A>
 must be specified before "ORG" can be used.
<P>
<STRONG>Source Code Organization</STRONG>
<P>
If "ORG" appears before any 
<A HREF="#l79">"SEGMENT"</A>
 or
<A HREF="#l80">"USESEGMENTS"</A>
 pseudo op, the source code is considered
monolithic ("one block").
If a "SEGMENT" or "USESEGMENTS" pseudo op appears before any "ORG", the
source code is considered segmented.
<P>
In monolithic source code "ORG" can be used at any time.
The program counter may assume the same value more than once.
All code and data is output as a single block in the same order
it is defined.
<P>
There is a limit of 1023 on the number of times two consecutive
object bytes can have non-consective addresses as determined by the
program counter.
That is, there can be no more than 1023 "address jumps" in a monolithic
program.
<P>
In segmented source code "ORG" can only be used 
<EM>within</EM>
 segment fragments.
In any particular segment "ORG" may be used any number of times in any
number of its fragments.
However every use in the same segment must have the same value
each time, and only the first use actually sets the program counter.
After that the program counter can only increase in value, and never repeats.
<P>
"ORG" flags the whole segment a fragment belongs to as 
<EM>absolute origin</EM>
.
Absolute origin segments are the only segment type in which
backward references are possible during the first pass.
Constant expressions may refer to locations and labels which are already
known at the time the expression is evaluated.
<P>
"ORG" cannot be used in any segment which already has another type.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l9c">Set Program Counter</A>
 - monolithic
<LI>
<A HREF="hxa_test.htm#la1">Basic Definition</A>
 - segmented
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l6d">PADTO</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>PADTO</STRONG>
<EM>const_expr [, hex_str ]</EM>
</CODE>
<P>
The "PADTO" pseudo op inserts bytes into the object code until
the program counter is a multiple of 
<EM>const_expr</EM>
.
That is, if the remainder of dividing the current value of the
program counter by 
<EM>const_expr</EM>
 is non-zero, pad bytes are inserted
until it is.
<P>
For example:
<P>
PADTO 2
<P>
inserts a zero byte into the output if the value of the program counter
is odd, otherwise it does nothing.
<P>
<EM>Const_expr</EM>
 must have a value in the range one
to the maximum value of the program counter plus one.
Otherwise "PADTO" is always ignored, and an error occurs if
<EM>const_expr</EM>
 is not zero.
<P>
Note that if 
<EM>const_expr</EM>
 is larger than the value of the program counter
at the time padding starts, it essentially represents an absolute address
to pad to, since that is where the first zero remainder will occur.
<P>
By default "PADTO" inserts zero bytes ($00) into the object code.
If the optional 
<EM>hex_str</EM>
 is supplied, its values are used instead.
Bytes are taken from 
<EM>hex_str</EM>
 in the same left-to-right
order they appear, regardless of CPU byte orientation.
<P>
"PADTO" uses only as many bytes of 
<EM>hex_str</EM>
 as needed.
If more are needed than 
<EM>hex_str</EM>
 supplies, it is duplicated
as often as required.
<P>
"PADTO" may be used in monolithic or segmented source whenever the
program counter is valid.
<P>
In monolithic source "PADTO" may be used any number of times with
any argument values.
Each time it is executed immediately.
Any padding appears in the object code starting at the current value
of the program counter.
<P>
In 
<A HREF="#l79">segmented</A>
 source "PADTO" can be used only within
fragments of 
<A HREF="#l6c">absolute origin</A>
 and 
<A HREF="#l76">relative origin</A>
 segments.
Any particular segment may use it any number of times, but it must have
the same value(s) each time.
Different segments may use different values for "PADTO".
Padding is delayed until address resolution occurs.
Any padding appears at the end of each padded segment in the object code.
<P>
Segments cannot be both padded and 
<A HREF="#l7f">uninitialized</A>
.
<P>
"PADTO" is affected by 
<A HREF="#l40">non-standard byte sizes</A>
.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l86">Pad to Specific Byte Boundary</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l6e">PAGE</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>PAGE</STRONG>
</CODE>
<P>
The "PAGE" pseudo op unconditionally prints enough blank lines to fill
the remainder of the current page in a listing file.
The next printed line will appear at the top of the next page.
<P>
"PAGE" has no effect during assembly, in 
<A HREF="#l6f">unpaginated</A>
listing files or in unlisted portions of the source code.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l8c">Formfeed</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l6f">PAGESIZE</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>PAGESIZE</STRONG>
<EM>const_expr1 [, const_expr2]</EM>
</CODE>
<P>
The "PAGESIZE" pseudo op sets the width and length of a page in a
<A HREF="#l50">listfile</A>
.
Both the width and length can be set to any value from zero to 255 inclusive.
<P>
<EM>Const_expr1</EM>
 controls the page width, the total number of characters that
can fit across a page (including margins).
The default value is 75.
A page width of zero is interpreted as meaning infinite width, so that every
output line is printed in its entirety without wrapping or truncation.
<P>
The page width can be altered independently of the page length.
<P>
The optional 
<EM>const_expr2</EM>
 controls the page length, the total number of
lines that can fit on a page (including margins).
The default value is zero, which is interpreted as meaning all output is
on one page of infinite length.
<P>
The default values are suitable for "printing" to files meant to be loaded
into a text editor, but may not be in other circumstances.
<P>
"PAGESIZE" may be used as many times as desired, but must have the same
value(s) each time.
Use of an illegal value causes an error and the affected parameter retains
its current value (although because of the error no listing will occur).
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l93">Pagination</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l70">PSALIAS</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>PSALIAS</STRONG>
<EM>psop=alias</EM>
<EM>[[, psop=alias]..]</EM>
</CODE>
<P>
The "PSALIAS" pseudo op assigns user-chosen names to existing pseudo op
names using 
<A HREF="#l7b">the equality idiom</A>
.
A user-chosen name can then be used in place of the original pseudo op
whereever it is legal to do so.
<P>
Alias names have the same form as 
<A HREF="#l37">global labels</A>
.
Aliases must be unique.
No two aliases can have the same name, nor can an
alias have the same name as an existing label or opcode.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l0f">Pseudo Op Names</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l71">PSNULL</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<EM>[label]</EM>
<STRONG>PSNULL</STRONG>
<EM>[text [,text1]..]</EM>
</CODE>
<P>
The "PSNULL" pseudo op simply ignores each and every 
<EM>label</EM>
 and
expression field value it may be associated with.
<P>
"PSNULL" is meant to ease porting source code to HXA.
Such code may contain one or more pseudo ops for which HXA has no
built-in equivalent.
If any can be safely ignored, they may be 
<A HREF="#l70">aliased</A>
 to "PSNULL",
which will allow HXA to effectively skip them whenever encountered.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l10">Pseudo Op Nullification</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l72">PUSHS</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>PUSHS</STRONG>
<EM>const_expr$|const_expr [[,const_expr$|const_expr]..]</EM>
</CODE>
<P>
The "PUSHS" pseudo op pushes its argument(s) onto the user string stack
as a single entry.
<P>
"PUSHS" treats its arguments as constant expressions to be evaluated.
Expressions may be either string or numeric.
Numeric expressions are coerced to one-character strings by the
equivalent of 
<EM>CHR$(const_expr & $FF)</EM>
.
<P>
All arguments are concatenated together before being pushed onto
the user stack.
Null strings are legal.
<P>
"PUSHS" is the complement of the 
<A HREF="#l1b">POP$()</A>
 function, which removes strings
from the user stack.
For every use of "PUSHS", there must be a later one of POP$().
The numbers must balance by the end of the first pass.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l66">User Stack</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l73">PUTBACK--</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>PUTBACK</STRONG>
<EM>[text [[,text]..]]</EM>
</CODE>
<P>
<CODE>
<STRONG>PUTBACKS</STRONG>
<EM>const_expr$|const_expr [[,const_expr$|const_expr]..]</EM>
</CODE>
<P>
Variants
<UL>
<LI>
<STRONG>PUTBACK</STRONG>
<EM>alias</EM>
<STRONG>ONEXPAND</STRONG>
<LI>
<STRONG>PUTBACKS</STRONG>
<EM>alias</EM>
<STRONG>PUTSTR</STRONG>
</UL>
<P>
The "PUTBACK--" pseudo ops "push back" their argument(s)
onto the input stream, which then become the next input line.
<P>
"PUTBACK" and "PUTBACKS" can only be used within
<A HREF="#l68">macro</A>
, 
<A HREF="#l77">repeat</A>
and 
<A HREF="#l82">while</A>
 blocks.
Outside of these they cause an error.
<P>
HXA normally performs a minimal amount of processing on every source code
line in order to verify required syntax.
The "PUTBACK--" pseudo ops satisfy this check during block definition.
Processing of the remainder of these "protected" source code lines
is delayed until expansion occurs.
<P>
<STRONG>PUTBACK</STRONG>
<P>
During block expansion, "PUTBACK" does nothing to its arguments
except remove any whitespace between comma-separated arguments.
The net effect is that the next input line read is the same as the
current line except that the leading "PUTBACK" has been removed.
<P>
This allows the use of formal macro arguments in the label and opcode
fields of a source line.
It can also be used to permit forward reference to a macro which is not
yet defined (including recursive macro definitions).
<P>
If "PUTBACK" has no argument or the argument has the form of a line
HXA normally ignores (eg., a comment), it does nothing.
<P>
<STRONG>PUTBACKS</STRONG>
<P>
During block expansion, "PUTBACKS" evaluates its arguments
as constant string or numeric expressions.
Numeric expressions are coerced to one-character strings by the
equivalent of 
<EM>CHR$(const_expr & $FF)</EM>
.
All evaluated arguments are concatenated together before being
"pushed back" onto the input.
<P>
"PUTBACKS" can be used to dynamically create input lines during assembly.
<P>
"PUTBACKS" requires at least one argument.
If the argument(s) evaluate to the null string, "PUTBACKS" issues a warning.
If to a line HXA normally ignores (eg., a comment), it does nothing.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l59">PUTBACK Pseudo Op</A>
<LI>
<A HREF="hxa_test.htm#l05">Deep Nesting</A>
<LI>
<A HREF="hxa_test.htm#l5a">PUTBACKS Pseudo Op</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l75">READONCE</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>READONCE</STRONG>
</CODE>
<P>
The "READONCE" pseudo op causes any file it is used in to be
silently ignored by any future 
<A HREF="#l65">"INCLUDE"</A>
 pseudo op.
It is meant to ensure that a particular file is included only once
in an assembly no matter how many times that file appears as the
operand of an "INCLUDE".
<P>
"READONCE" can be used anywhere in a file.
A warning is issued if HXA detects that the file has used "INCLUDE"
(or "INCBIN") before "READONCE" because of the possibility of
circular file references.
<P>
"READONCE" prevents future inclusion based on the full name
(including any path) of the file currently being read.
It cannot prevent at least one extra inclusion for each different path to
the same file supplied to "INCLUDE".
Because of that possibility a warning can be issued if the base filename
(the part following any path information) matches the base filename
of any previously included file.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l2f">Read Exclusion</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l74">RBIT--</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<EM>[label]</EM>
<STRONG>RBIT--</STRONG>
<EM>num_expr [[,num_expr]..]</EM>
</CODE>
<P>
Variants
<UL>
<LI>
<STRONG>RBIT08</STRONG>
<LI>
<STRONG>RBIT16</STRONG>
; 
<STRONG>RBIT16R</STRONG>
<LI>
<STRONG>RBIT24</STRONG>
; 
<STRONG>RBIT24R</STRONG>
<LI>
<STRONG>RBIT32</STRONG>
; 
<STRONG>RBIT32R</STRONG>
</UL>
<P>
The "RBIT--" pseudo ops store part or all of a signed 
<EM>offset_value</EM>
relative to the 
<EM>program_counter</EM>
 into the object code.
<P>
The offset value is calculated as:
<P>
<EM>offset_value</EM>
 = 
<EM>num_expr</EM>
 - (
<EM>program_counter</EM>
 + 
<EM>data_size</EM>
)
<P>
<EM>Num_expr</EM>
 is a 32-bit signed integer value.
<EM>Program_counter</EM>
 is the value of the program counter at the first byte
of the stored data.
<EM>Data_size</EM>
 is the number of bytes of data stored (the same as the number
of bits divided by eight).
<P>
In other words, the value of the program counter at the location immediately
following the stored data is subtracted from 
<EM>num_expr</EM>
 to create
the actual value stored.
<P>
"RBIT08" stores the least significant 8 bits,
"RBIT16-" the least significant 16 bits,
"RBIT24-" the least significant 24 bits, and
"RBIT32-" the entire 32 bits.
<P>
The "RBIT--" pseudo ops perform two range checks before storing any values.
<P>
First, 
<EM>num_expr</EM>
 must be within the program counter range.
That is, it must be greater than or equal to zero and less than 2^(pc_bits).
For example, with a 16-bit program counter the maximum value of 
<EM>num_expr</EM>
must be less than 2^16 (= 65536, or $10000).
<P>
Second, 
<EM>offset_value</EM>
 must fit into the storage space allowed.
That is, bits not stored must be zero.
Note 
<EM>offset_value</EM>
 is positive if 
<EM>num_expr</EM>
 is greater than
<EM>program_counter</EM>
 + 
<EM>data_size</EM>
, otherwise it is negative.
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>RBIT-- Ranges</CAPTION>
<TR ALIGN=CENTER>
<TD>
<STRONG>Pseudo Op</STRONG>
<TD>
<STRONG>Min Dec</STRONG>
<TD>
<STRONG>Max Dec</STRONG>
<TD>
<STRONG>Min Hex</STRONG>
<TD>
<STRONG>Max Hex</STRONG>
<TR ALIGN=CENTER>
<TD>
RBIT08-
<TD>
-128
<TD>
127
<TD>
$00000080
<TD>
$0000007F
<TR ALIGN=CENTER>
<TD>
RBIT16-
<TD>
-32768
<TD>
32767
<TD>
$00008000
<TD>
$00007FFF
<TR ALIGN=CENTER>
<TD>
RBIT24-
<TD>
-8388608
<TD>
8388607
<TD>
$00800000
<TD>
$007FFFFF
<TR ALIGN=CENTER>
<TD>
RBIT32-
<TD>
-2147483648
<TD>
2147483647
<TD>
$80000000
<TD>
$7FFFFFFF
</TABLE>
<P>
By default storage of multi-byte values is in native CPU order, either
least significant byte (LSB) first or most significant byte (MSB) first.
The "R" suffix reverses the native order of stored bytes, so "RBIT24R" used
on an LSB first CPU will store the MSB first in the object code.
<P>
The "RBIT--" pseudo ops require at least one numeric expression argument.
Each separate expression is treated a separate value to be stored
according to the specific "RBIT--" rules.
<P>
The available "RBIT--" pseudo ops are affected by 
<A HREF="#l40">non-standard byte sizes</A>
.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l1e">Program Counter Relative Numeric Data Definition</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l76">RELORG</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
RELORG
</CODE>
<P>
The "RELORG" pseudo op makes a 
<A HREF="#l79">segment</A>
<EM>relative origin</EM>
.
When it is made absolute it will start at the ending address of the
preceeding segment.
That is, one past the last address actually used by that segment.
<P>
Use of "RELORG" is optional because it is the default segment type.
If a segment program counter changes before any type is explicitly
declared, that segment automatically becomes relative origin.
However "RELORG" can make the intention explicit, and may also help
prevent accidentally setting another type later.
<P>
A relative origin segment cannot be the first segment, nor
may it immediately follow a 
<A HREF="#l4f">relative end</A>
 segment.
<P>
"RELORG" may only be used within a segment fragment.
It is the only type that does not have to be used before the
segment program counter changes.
It may be used any number of times in the same segment.
<P>
"RELORG" cannot be used in any segment which already has another type.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l9f">"RELORG" Pseudo Op</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l77">REPEAT..ENDREPEAT</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<EM>[label]</EM>
<STRONG>REPEAT</STRONG>
<EM>const_expr</EM>
</CODE>
<P>
<CODE>
<EM>[[source code]..]</EM>
</CODE>
<P>
<CODE>
<EM>[label]</EM>
<STRONG>ENDREPEAT</STRONG>
</CODE>
<P>
Variants
<UL>
<LI>
<STRONG>ENDREPEAT</STRONG>
<EM>alias</EM>
<STRONG>ENDR</STRONG>
</UL>
<P>
A 
<EM>repeat block</EM>
 consists of an unnamed group of zero or more source code
lines delimited by a matched pair of "REPEAT".."ENDREPEAT" pseudo ops.
The grouped source lines are called the 
<EM>body</EM>
 of the repeat block.
<P>
A "REPEAT".."ENDREPEAT" pair is used to 
<EM>define</EM>
 a repeat block.
Because they are unnamed (and thus cannot be referred to later),
repeat blocks are 
<EM>expanded</EM>
 as soon as their definition is complete.
The expansion has the effect of duplicating the body of the repeat block
<EM>const_expr</EM>
 number of times into the source code at that point.
If 
<EM>const_expr</EM>
 is less than one, the body is skipped and there is no
effect.
<P>
Repeat blocks are an advanced assembler function.
They are not necessary, but are particularly helpful for building
tables of data.
<P>
<STRONG>Repeat Blocks and Local Scopes</STRONG>
<P>
Repeat blocks may be nested to any depth by directly nesting
"REPEAT".."ENDREPEAT" pairs.
<P>
Every individual repeat expansion block causes a nested local scope
to be created without ending the existing one.
Each repeat expansion block creates only one local scope
no matter how many times the repeat body is duplicated.
As each expansion ends, so does the nested local scope it created.
<P>
Note that the 
<EM>const_expr</EM>
 controlling any repeat block
is not evaluated until that block is expanded.
This allows the control expression of a nested repeat block to depend on
values which are set only during the expansion of a nesting block.
<P>
Repeat blocks are similar to 
<A HREF="#l82">while blocks</A>
,
except with a fixed rather than conditional control expression.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l95">Repeats</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l78">SBIT--</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<EM>[label]</EM>
<STRONG>SBIT--</STRONG>
<EM>num_expr [[,num_expr]..]</EM>
</CODE>
<P>
Variants
<UL>
<LI>
<STRONG>SBIT08</STRONG>
<LI>
<STRONG>SBIT16</STRONG>
; 
<STRONG>SBIT16R</STRONG>
<LI>
<STRONG>SBIT24</STRONG>
; 
<STRONG>SBIT24R</STRONG>
<LI>
<STRONG>SBIT32</STRONG>
; 
<STRONG>SBIT32R</STRONG>
</UL>
<P>
The "SBIT--" pseudo ops store all or part of 
<EM>num_expr</EM>
into the object code.
<P>
<EM>Num_expr</EM>
 is a signed 32-bit integer value.
<P>
"SBIT08" stores the least significant 8 bits,
"SBIT16-" the least significant 16 bits,
"SBIT24-" the least significant 24 bits, and
"SBIT32-" the entire 32 bits.
<P>
The "SBIT--" pseudo ops generate an error if 
<EM>num_expr</EM>
will not fit into the storage space allowed.
That is, bits not stored must be zero.
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>SBIT-- Ranges</CAPTION>
<TR ALIGN=CENTER>
<TD>
<STRONG>Pseudo Op</STRONG>
<TD>
<STRONG>Min Dec</STRONG>
<TD>
<STRONG>Max Dec</STRONG>
<TD>
<STRONG>Min Hex</STRONG>
<TD>
<STRONG>Max Hex</STRONG>
<TR ALIGN=CENTER>
<TD>
SBIT08-
<TD>
-128
<TD>
127
<TD>
$00000080
<TD>
$0000007F
<TR ALIGN=CENTER>
<TD>
SBIT16-
<TD>
-32768
<TD>
32767
<TD>
$00008000
<TD>
$00007FFF
<TR ALIGN=CENTER>
<TD>
SBIT24-
<TD>
-8388608
<TD>
8388607
<TD>
$00800000
<TD>
$007FFFFF
<TR ALIGN=CENTER>
<TD>
SBIT32-
<TD>
-2147483648
<TD>
2147483647
<TD>
$80000000
<TD>
$7FFFFFFF
</TABLE>
<P>
By default storage of multi-byte values is in native CPU order, either
least significant byte (LSB) first or most significant byte (MSB) first.
The "R" suffix reverses the native order of stored bytes, so "SBIT24R" used
on an LSB first CPU will store the MSB first in the object code.
<P>
The "SBIT--" pseudo ops require at least one numeric expression argument.
Each separate expression is treated a separate signed value to be stored
according to the specific "SBIT--" rules.
<P>
The available "SBIT--" pseudo ops are affected by 
<A HREF="#l40">non-standard byte sizes</A>
.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l1f">Ranged Numeric Data Definition</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l79">SEGMENT..ENDSEGMENT</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>SEGMENT</STRONG>
<EM>name$</EM>
</CODE>
<P>
<CODE>
<EM>[[source code]..]</EM>
</CODE>
<P>
<CODE>
<STRONG>ENDSEGMENT</STRONG>
<EM>[name$]</EM>
</CODE>
<P>
Variants
<UL>
<LI>
<STRONG>ENDSEGMENT</STRONG>
<EM>alias</EM>
<STRONG>ENDS</STRONG>
</UL>
<P>
By default HXA assumes source code is organzied in a 
<EM>monolithic</EM>
("one block") manner.
This means that it is in the same order as the physical object code to
be produced.
<P>
<EM>Segments</EM>
 are an optional method of organizing source code in a
manner convenient to the programmer while still providing complete
control over the object code order.
<P>
A 
<EM>segment fragment</EM>
 consists of a named group of zero or more source code
lines delimited by a matched pair of "SEGMENT..ENDSEGMENT" pseudo ops.
The grouped source lines are called the 
<EM>body</EM>
 of the segment fragment.
<P>
A "SEGMENT..ENDSEGMENT" pair identifies a segment fragment
as belonging to a particular named 
<EM>segment</EM>
.
All segment fragments with the same name belong to the same segment,
regardless of where in the source code they appear.
<P>
A segment fragment does not necessarily have to contain code or data.
If no fragment of a segment contains code or data (eg., it is used
only to specify where in memory certain variables are to be placed),
then that segment will not appear in the object file.
<P>
If an object file is created, all segments which have at least one fragment
containing code or data will be output in the same order those segments
were first encountered in the source code.
<P>
One way to control the order of all segments is to create a "segment map"
near the start of the source code that simply creates one fragment
for every segment to be used.
The fragments can be typed here, but do not have to contain any code or data.
This organization allows convenient changes to the "map" whenever necessary.
<P>
For each segment output, all the non-empty fragments of that segment will
be output in the same order 
<EM>they</EM>
 were first encountered in the source
code.
All the non-empty fragments of the same segment thus appear as a single
block in the object file.
This is how the physical order of the object code may be different from the
physical order of the source code which created that object.
<P>
<STRONG>Source Code Organization</STRONG>
<P>
Although in principle there is nothing to stop an assembly language
program from freely mixing together executable code, constant data
and variable locations in the object code, in practice these are
usually separated into separate memory blocks for both safety and
consistency.
To accomplish this with monolithic source code often means placing
constant data and variable locations far away from the executable code
that will use them.
<P>
Segments offer the advantage that in the source executable code
can be placed near the constant data and variable locations it will use,
and in the object code these will all be cleanly separated from each other.
The main disadvantage is that segments require explicit management.
<P>
<STRONG>Selecting Monolithic or Segmented Source Code</STRONG>
<P>
The decision to use a monolithic or segmented source code
organization is an all-or-nothing choice.
HXA does not permit the two approaches to be mixed.
Programmers should choose whichever form makes their task easiest.
<P>
The default monolithic organization is chosen if the 
<A HREF="#l6c">"ORG"</A>
 pseudo op
is used before and outside of any segment fragment.
That is, if HXA encounters "ORG" before "SEGMENT"
(or 
<A HREF="#l80">"USESEGMENTS"</A>
), the organization is monolithic
and no segments will be allowed.
<P>
The optional segmented organization is chosen if "ORG" is first used
inside a segment fragment.
That is, if HXA encounters "SEGMENT" (or "USESEGMENTS") before the
first "ORG", the organization is segmented.
The program counter is then invalid outside of any segment fragment,
and every "ORG" used must appear 
<EM>within</EM>
 a segment fragment.
<P>
<STRONG>Segment Types</STRONG>
<P>
HXA recognizes four types of segments: 
<A HREF="#l6c">absolute origin</A>
,
<A HREF="#l76">relative origin</A>
, 
<A HREF="#l4f">absolute end and relative end</A>
.
Any of these types may also be flagged as 
<A HREF="#l56">common</A>
 segments, which
do not hold any data and are used only for variable storage.
<P>
Every segment has its own program counter, each the same size
as the 
<A HREF="#l57">"CPU"</A>
 program counter.
Unlike a monolithic program counter, segment program counters
can only increase in value.
They can never be reset to go down in value or repeat themselves.
<P>
The default segment type is relative origin.
All other types must be explicitly declared.
It is usually convenient that a declaration appears in the
first fragment of any particular segment, but not necessary.
A declaration may actually appear in any fragment as long as the
segment program counter has not yet changed.
That is, before any code or data has been stored or the 
<A HREF="#l58">"DS"</A>
pseudo op has been used.
<P>
There 
<STRONG>must be at least one absolute segment</STRONG>
, which can be either
absolute origin or absolute end.
If there 
<EM>is</EM>
 only one, it can be preceeded only by relative end
segments, and can be followed only by relative origin segments.
<P>
<STRONG>Segments and Forward Reference</STRONG>
<P>
If a segment is not absolute origin, the only labels within it
which have a value known during the first pass are those defined by
<A HREF="#l5b">"EQU"</A>
.
The values of all other labels in such segments depend directly
or indirectly on the segment program counter, which during the first pass
represents an offset rather than an absolute address.
Hence in expressions all use of these labels, or the segment program counter
itself, are 
<A HREF="#l2a">forward references</A>
.
<P>
In general this does not cause any difficulty, as HXA resolves (or forbids)
these references as it does all forward references.
However because 
<EM>all</EM>
 references to labels defined in
non-absolute origin segments are forward, some expressions which work
perfectly well in monolithic programs will fail in segmented programs.
<P>
For example, in a monolithic program the value of any label which
has appeared in the label column of a source line is available for
use in any expression context.
But in non-absolute segments, similar labels can be used in constant
expressions only if they were part of an "EQU" assignment.
<P>
<STRONG>Segments and Local Scopes</STRONG>
<P>
Segment fragments may be nested to any depth by directly nesting
"SEGMENT".."ENDSEGMENT" pairs.
It is legal for a fragment to nest inside another fragment
of the same segment.
<P>
Every segment fragment causes a nested local scope to be created
without ending the existing one.
As each fragment ends, so does the nested local scope it created.
<P>
<STRONG>Monolithic vs. Segmented Source Code</STRONG>
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Significant Differences</CAPTION>
<TR ALIGN=CENTER>
<TD>
-
<TD>
Monolithic
<TD>
Segmented
<TR ALIGN=CENTER>
<TD>
Max# Segments
<TD>
1023*
<TD>
1023
<TR ALIGN=CENTER>
<TD>
Max# Segment Fragments
<TD>
n/a
<TD>
unlimited
<TR ALIGN=CENTER>
<TD>
<A HREF="#l67">Listing File</A>
<TD>
no segment map
<TD>
default segment map
<TR ALIGN=CENTER>
<TD>
<A HREF="#l58">"DS" psop</A>
<TD>
value can be negative
<TD>
value cannot be negative
<TR ALIGN=CENTER>
<TD>
<A HREF="#l5a">"END" psop</A>
<TD>
can be labelled
<TD>
cannot be labelled
<TR ALIGN=CENTER>
<TD>
<A HREF="#l6c">"ORG" psop</A>
<TD>
any value any time
<TD>
one value per absolute segment
<TR ALIGN=CENTER>
<TD>
<A HREF="#l6d">"PADTO" psop</A>
<TD>
any value any time; immediate execution; pads from current pc value
<TD>
one value per segment; delayed execution; pads at end of segment
</TABLE>
<P>
Notes:
<UL>
<LI>
* = HXA uses "implicit" segments in its internal data structures
even in monolithic programs.
A new "segment" is created whenever use of "ORG" or "DS" causes
consecutively generated data to be stored at non-consecutive addresses.
</UL>
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l9d">Segments</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l7a">STRING--</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<EM>[label]</EM>
<STRONG>STRING--</STRONG>
<EM>const_expr$|const_expr [[,const_expr$|const_expr]..]</EM>
</CODE>
<P>
Variants
<UL>
<LI>
<STRONG>STRING</STRONG>
<EM>alias</EM>
<STRONG>STR</STRONG>
<LI>
<STRONG>STRINGR</STRONG>
<EM>alias</EM>
<STRONG>REVSTR</STRONG>
</UL>
<P>
The "STRING--" pseudo ops store characters into the object code.
Each character is mapped through the current
<A HREF="#l83">character set translation</A>
 before being stored.
<P>
At least one argument is required.
It must be a constant expression, but can be either string or numeric.
Numeric arguments are coerced to one-character strings by the
equivalent of 
<EM>CHR$(const_expr & $FF)</EM>
.
<P>
If more than one argument is provided, all are concatenated together as
one string before storage.
<P>
Object bytes are stored consecutively starting at the current program
counter location.
"STRING" proceeds from left to right through its (concatenated) argument(s).
That is, in the order they appear as arguments.
"STRINGR" processes its (concatenated) argument(s) from right to left.
That is, in reverse order.
<P>
If the result of concatenation is null HXA issues a warning
and no object code is created.
<P>
Note that some assemblers allow mixed string and numeric expressions
to follow "BYTE" (or equivalent) pseudo ops.
HXA does not permit this for 
<A HREF="#l54">"BIT--"</A>
, but does for "STRING".
<P>
Character values in strings are affected by 
<A HREF="#l40">non-standard byte sizes</A>
.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l24">String Literals</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l51">--TIMER</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>--TIMER</STRONG>
<EM>name$</EM>
</CODE>
<P>
Variants
<UL>
<LI>
STARTTIMER
<LI>
STOPTIMER
<LI>
SHOWTIMER
</UL>
<P>
The "--TIMER" pseudo ops provide programmer access to the same
start, stop and elapsed time functions HXA uses to measure its
own pass times.
User-named timers allow comparisons of the assembly times
of alternative program constructs to be made.
<P>
Names must be unique within all timers.
No two timers can have the same name.
<P>
Timers are accurate only to the nearest second.
<P>
"STARTTIMER" creates a new timer and records the current time.
This pseudo op may be used only once for any given timer.
<P>
"STOPTIMER" stops the named timer and records the current time.
This pseudo op may be used only once for any given timer.
<P>
"SHOWTIMER" 
<A HREF="#l59">echoes</A>
 the value of the named timer
in "HH:MM:SS" format.
If the timer is stopped, the value is the difference between its
start and stop times.
If the timer is not stopped, the value is the difference between its
start time and the current time.
This pseudo op may be used any number of times with any given timer.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l64">Timers</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l7c">TITLE</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>TITLE</STRONG>
<EM>[opt_str]</EM>
</CODE>
<P>
The "TITLE" pseudo op replaces the default document title of an HXA
list file with 
<EM>opt_str</EM>
.
<P>
The title appears once starting at the first printable line of the first
page of a listing.
<P>
If 
<EM>opt_str</EM>
 is not provided or is the null string, the listing file will
have no title but the first line will be blank.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l88">Change Header</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l7d">UBIT--</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<EM>[label]</EM>
<STRONG>UBIT--</STRONG>
<EM>num_expr [[,num_expr]..]</EM>
</CODE>
<P>
Variants
<UL>
<LI>
<STRONG>UBIT08</STRONG>
<LI>
<STRONG>UBIT16</STRONG>
; 
<STRONG>UBIT16R</STRONG>
<LI>
<STRONG>UBIT24</STRONG>
; 
<STRONG>UBIT24R</STRONG>
<LI>
<STRONG>UBIT32</STRONG>
; 
<STRONG>UBIT32R</STRONG>
</UL>
<P>
The "UBIT--" pseudo ops store all or part of 
<EM>num_expr</EM>
into the object code.
<P>
<EM>Num_expr</EM>
 is an unsigned 32-bit integer value.
<P>
"UBIT08" stores the least significant 8 bits,
"UBIT16-" the least significant 16 bits,
"UBIT24-" the least significant 24 bits, and
"UBIT32 the entire 32 bits.
<P>
The "UBIT--" pseudo ops generate an error if 
<EM>num_expr</EM>
will not fit into the storage space allowed.
That is, bits not stored must be zero.
<P>
The available "UBIT--" pseudo ops are affected by 
<A HREF="#l40">non-standard byte sizes</A>
.
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>UBIT-- Ranges</CAPTION>
<TR ALIGN=CENTER>
<TD>
<STRONG>Pseudo Op</STRONG>
<TD>
<STRONG>Min Dec</STRONG>
<TD>
<STRONG>Max Dec</STRONG>
<TD>
<STRONG>Min Hex</STRONG>
<TD>
<STRONG>Max Hex</STRONG>
<TR ALIGN=CENTER>
<TD>
UBIT08-
<TD>
0
<TD>
255
<TD>
$00000000
<TD>
$000000FF
<TR ALIGN=CENTER>
<TD>
UBIT16-
<TD>
0
<TD>
65535
<TD>
$00000000
<TD>
$0000FFFF
<TR ALIGN=CENTER>
<TD>
UBIT24-
<TD>
0
<TD>
16777215
<TD>
$00000000
<TD>
$00FFFFFF
<TR ALIGN=CENTER>
<TD>
UBIT32-
<TD>
0
<TD>
4294967295
<TD>
$00000000
<TD>
$FFFFFFFF
</TABLE>
<P>
By default storage of multi-byte values is in native CPU order, either
least significant byte (LSB) first or most significant byte (MSB) first.
The "R" suffix reverses the native order of stored bytes, so "UBIT24R" used
on an LSB first CPU will store the MSB first in the object code.
<P>
The "UBIT--" pseudo ops require at least one numeric expression argument.
Each separate expression is treated a separate unsigned value to be stored
according to the specific "UBIT--" rules.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l1f">Ranged Numeric Data Definition</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l7e">UNDEF</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>UNDEF</STRONG>
<EM>name$ [[, name$]..]</EM>
</CODE>
<P>
The "UNDEF" pseudo op deletes each 
<EM>name$</EM>
 from the current set of
<A HREF="#l68">macro definitions</A>
 known to HXA.
<P>
It is not an error to delete a macro which is not currently defined.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l52">DEFINED() and UNDEF</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l7f">UNINITIALIZED</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>UNINITIALIZED</STRONG>
</CODE>
<P>
Variants
<P>
<STRONG>UNINITIALIZED</STRONG>
<EM>alias</EM>
<STRONG>NODATA</STRONG>
<P>
"UNINITIALZED" explicitly flags a 
<A HREF="#l79">segment</A>
 as containing
no code or data.
<P>
This pseudo op can be used any number of times within any fragment of a segment.
However the first use must occur before any data is stored in any fragment
of that segment or each one causes an error.
<P>
Once a segment has been flagged as uninitialized any attempt to store data
in that segment is an error.
<P>
Every uninitialized segment has a starting and ending address and a length,
but has no offset value in the output file because it will not be output.
<P>
The 
<A HREF="#l56">"COMMON"</A>
 and 
<A HREF="#l58">"DS"</A>
 pseudo ops can be used in
uninitialized segments.
They also implicitly flag a segment as uninitialized if they are legally
used in a segment which has not already been explicitly declared to be. 
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l80">USESEGMENTS</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>USESEGMENTS</STRONG>
</CODE>
<P>
The "USESEGMENTS" pseudo op explicitly instructs HXA to treat the source
program as 
<A HREF="#l79">segmented</A>
 rather than monolithic.
<P>
"USESEGMENTS" can be used as often as desired both within and outside
segments, but only the first use actually does anything.
The main restriction is that "USESEGMENTS" must be used before the first
<A HREF="#l6c">"ORG"</A>
 pseudo op, otherwise the source program is treated as
monolithic and "USESEGMENTS" is not allowed.
<P>
Use of this pseudo op is optional because the "SEGMENTS" pseudo op
implicitly performs the same task as "USESEGMENTS".
However, it can help make programmer intent clearer.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#la0">"USESEGMENTS" psop</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l81">WARN</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>WARN</STRONG>
<EM>[opt_str]</EM>
</CODE>
<P>
The "WARN" pseudo op enables programmer-triggered warning messages.
<P>
These messages are the same in every respect as their internally
triggered equivalents.
They are sent to 
<EM>stdout</EM>
 and also to
to the 
<A HREF="#l50">error file</A>
 if one has been specified.
The "WARN" pseudo op also contributes to the running total
of such messages necessary to halt assembly altogether.
<P>
The optional 
<EM>opt_str</EM>
 argument can be used to provide a more detailed
description of what triggered the message.
In particular, a string expression may be used to display the value(s) of
one or more labels at the point of the warning.
<P>
While there are no hard and fast rules as to which message type is
appropriate when, HXA itself generally uses these
<A HREF="#l5d">guidelines</A>
.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l5e">User Messages</A>
<LI>
<A HREF="hxa_test.htm#l65">User Messages w/ String Expressions</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l82">WHILE..ENDWHILE</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<EM>[label]</EM>
<STRONG>WHILE</STRONG>
<EM>conditional_expr</EM>
</CODE>
<P>
<CODE>
<EM>[[source code]..]</EM>
</CODE>
<P>
<CODE>
<EM>[label]</EM>
<STRONG>ENDWHILE</STRONG>
</CODE>
<P>
Variants
<UL>
<LI>
<STRONG>ENDWHILE</STRONG>
<EM>alias</EM>
<STRONG>ENDW</STRONG>
</UL>
<P>
A 
<EM>while block</EM>
 consists of an unnamed group of zero or more source code
lines delimited by a matched pair of "WHILE".."ENDWHILE" pseudo ops.
The grouped source lines are called the 
<EM>body</EM>
 of the while block.
<P>
A "WHILE".."ENDWHILE" pair is used to 
<EM>define</EM>
 a while block.
Because they are unnamed (and thus cannot be referred to later),
while blocks are 
<EM>expanded</EM>
 as soon as their definition is complete.
<EM>Conditional_expr</EM>
 is evaluated, and if it is TRUE the body of the
while block is duplicated into the source code at that point.
If FALSE, the body is skipped and there is no effect.
<P>
<EM>Conditional_expr</EM>
 is re-evaluated each time the body has been
completely processed by the assembler.
As long as the result is TRUE the body is duplicated once more.
<P>
While blocks are an advanced assembler function.
They are not necessary, but are particularly helpful for building
tables of data.
<P>
<STRONG>While Blocks and Local Scopes</STRONG>
<P>
While blocks may be nested to any depth by directly nesting
"WHILE".."ENDWHILE" pairs.
<P>
Every individual while expansion block causes a nested local scope
to be created without ending the existing one.
Each while expansion block creates only one local scope
no matter how many times the while body is duplicated.
As each expansion ends, so does the nested local scope it created.
<P>
Note that the 
<EM>conditional_expr</EM>
 controlling any while block
is not evaluated for the first time until that block is expanded.
This allows the control expression of a nested while block to depend on
values which are set only during the expansion of a nesting block.
<P>
While blocks are similar to 
<A HREF="#l77">repeat blocks</A>
,
except with a conditional rather than fixed control expression.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#lbf">Whiles</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=16%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l83">XLATE</A>
</BIG>
</STRONG>
</CENTER>
<P>
<CODE>
<STRONG>XLATE</STRONG>
<EM>code=value</EM>
<EM>[[, code=value]..]</EM>
</CODE>
<P>
All character codes that appear as arguments of a 
<A HREF="#l7a">STRING--</A>
 pseudo op or
<A HREF="#l22">XLATE()</A>
 function are subject to 
<EM>translation</EM>
.
Character code values in the range zero to 255 are re-mapped to
arbitrary values in the range zero to 255 by means of a 
<EM>translation table</EM>
.
Translation permits use of the ASCII character set in a program destined for
a non-ASCII environment.
<P>
The default translation table simply maps each code value to itself.
The "XLATE" pseudo op alters the translation table.
<P>
"XLATE" uses 
<A HREF="#l7b">the equality idiom</A>
 to specify how character codes
are to be re-mapped.
There are several different forms of "XLATE" arguments depending
on how many character codes are to be re-mapped at one time.
<P>
<STRONG>Map One New Value onto One Character Code</STRONG>
<P>
<UL>
<LI>
<EM>code</EM>
<STRONG>=</STRONG>
<EM>value</EM>
</UL>
<P>
Both 
<EM>code</EM>
 and 
<EM>value</EM>
 are either single printable characters or
<A HREF="#l25">escape sequences</A>
.
If expressed as a printable character, the ASCII value of the character
is used.
<P>
<STRONG>Map One New Value onto a Range of Character Codes</STRONG>
<P>
<UL>
<LI>
<EM>begcode-endcode</EM>
<STRONG>=</STRONG>
<EM>value</EM>
</UL>
<P>
A range is expressed as a character code, followed by a dash ('-'),
followed by a character code.
<P>
HXA will issue a warning if the end of any range is less than
its start, and nothing will happen.
<P>
<STRONG>Map a Range of New Values onto a Range of Character Codes</STRONG>
<P>
<UL>
<LI>
<EM>begcode-endcode</EM>
<STRONG>=</STRONG>
<EM>begvalue-endvalue</EM>
</UL>
<P>
HXA does not complain if the two ranges are not equal in extent.
If the code range is smaller, re-mapping stops when the end of the
code range is reached.
If the value range is smaller, its last value is repeated until
the code range is complete.
<P>
<STRONG>Map A Range of New Values onto One Character Code</STRONG>
<P>
<UL>
<LI>
<EM>code</EM>
<STRONG>=</STRONG>
<EM>begvalue-endvalue</EM>
</UL>
<P>
This form is legal but merely maps 
<EM>begvalue</EM>
 onto 
<EM>code</EM>
 and stops.
It is equivalent to the first form listed.
<P>
Examples
<UL>
<LI>
<A HREF="hxa_test.htm#l28">XLATE() and XLATE</A>
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=50%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l40">Non-Standard BYTE Sizes</A>
</BIG>
</STRONG>
</CENTER>
<P>
<UL>
<LI><A HREF="#l42">BIT-- Pseudo Ops</A>
<LI><A HREF="#l43">FILL Pseudo Op</A>
<LI><A HREF="#l44">HEX Pseudo Op</A>
<LI><A HREF="#l46">INCBIN Pseudo Op</A>
<LI><A HREF="#l47">PADTO Pseudo Op</A>
<LI><A HREF="#l48">STRING-- Pseudo Ops</A>
<LI><A HREF="#l41">Bit Extraction Operators</A>
<LI><A HREF="#l45">Hexadecimal Output Files</A>
</UL>
<P>
The most common contemporary size of a processor's smallest addressable unit
is eight bits, also commonly known as a "byte".
However this is not the only possible size, and historically many
processors have used other minimum addressable unit sizes.
<P>
For convenience we'll continue to call the minimum addressable unit of any
processor a "byte".
If we want to particularly distinguish an 8-bit byte we will refer to an
"octet".
<P>
HXA can handle processor "byte" sizes of 8-, 16- and 32-bits.
Which size to use is specified by the 
<A HREF="hxa_t.htm#l0a">CPU descriptor</A>
 during
initialization.
<P>
The main documentation generally assumes a "byte" is equivalent
to an "octet".
This document outlines what changes when they are not the same.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l42">BIT-- Pseudo Ops</A>
</BIG>
</STRONG>
</CENTER>
<P>
<A HREF="#l54">Base description</A>
 (BIT-- form; RBIT--, SBIT-- and UBIT-- also)
<P>
The "bytes" of the base description refer to octet values.
<P>
The pseudo opcodes "-BYTE-", "-WORD-" and "-LONG-" are actually aliases
for various "-BIT--" pseudo opcodes.
Which "-BIT--" pseudo opcodes they alias changes depending on the byte size.
Not all aliases are available in every byte size.
<P>
Alias Assignments
<UL>
<LI>
"BYTE" aliases the smallest addressable unit
<LI>
"WORD" aliases two of the smallest addressable units
<LI>
"LONG" aliases four of the smallest addressable units
</UL>
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Byte Size vs. -BIT-- Availability</CAPTION>
<TR ALIGN=CENTER>
<TD>
-
<TD>
<STRONG>8 Bits</STRONG>
<TD>
<STRONG>Alias</STRONG>
<TD>
<STRONG>16 Bits</STRONG>
<TD>
<STRONG>Alias</STRONG>
<TD>
<STRONG>32 Bits</STRONG>
<TD>
<STRONG>Alias</STRONG>
<TR ALIGN=CENTER>
<TD>
-BIT08-
<TD>
Yes
<TD>
BYTE
<TD>
n/a
<TD>
n/a
<TD>
n/a
<TD>
n/a
<TR ALIGN=CENTER>
<TD>
-BIT16-
<TD>
Yes
<TD>
WORD
<TD>
Yes
<TD>
BYTE
<TD>
n/a
<TD>
n/a
<TR ALIGN=CENTER>
<TD>
-BIT24-
<TD>
Yes
<TD>
n/a
<TD>
n/a
<TD>
n/a
<TD>
n/a
<TD>
n/a
<TR ALIGN=CENTER>
<TD>
-BIT32-
<TD>
Yes
<TD>
LONG
<TD>
Yes
<TD>
WORD
<TD>
Yes
<TD>
BYTE
</TABLE>
<P>
Notes
<UL>
<LI>
for any given byte size, only that size -BIT-- pseudo op and
integer multiples of it are available.
Use of unavailable -BIT-- pseudo ops causes an error
</UL>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l43">FILL Pseudo Op</A>
</BIG>
</STRONG>
</CENTER>
<P>
<A HREF="#l60">Base description</A>
<P>
The number of bytes to fill automatically takes into account the byte size,
so the description remains valid.
<P>
If the optional fill value is supplied and number of octets it contains
is not an integer multiple of the byte size, the last byte will be
silently padded with trailing nulls ($00) to reach it.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l44">HEX Pseudo Op</A>
</BIG>
</STRONG>
</CENTER>
<P>
<A HREF="#l61">Base description</A>
<P>
The "bytes" in the base description refer to octet values.
<P>
If the number of octets supplied is not an integer multiple of the byte size,
the last byte will be silently padded with trailing nulls ($00) to reach it.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l46">INCBIN Pseudo Op</A>
</BIG>
</STRONG>
</CENTER>
<P>
<A HREF="#l64">Base description</A>
<P>
The optional numeric expressions representing how much to read and
the starting file offset represent octet values, ie., "standard bytes".
<P>
If the number of octets read is not an integer multiple of the byte size,
the last byte will be silently padded with trailing nulls ($00) to reach it.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l47">PADTO Pseudo Op</A>
</BIG>
</STRONG>
</CENTER>
<P>
<A HREF="#l6d">Base description</A>
<P>
The value to pad to automatically takes into account the byte size, so
the description remains valid.
<P>
If the optional pad value is supplied and number of octets it contains
is not an integer multiple of the byte size, the last byte will be
silently padded with trailing nulls ($00) to reach it.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l48">STRING-- Pseudo Ops</A>
</BIG>
</STRONG>
</CENTER>
<P>
<A HREF="#l7a">Base description</A>
<P>
Characters are always octet values in the range $00-FF.
<P>
If a byte is larger than an octect, string characters will be padded with
nulls ($00) to reach the byte size.
The nulls will appear on the "left" or "right" of the character octet
depending on whether the processor is Most Significant Byte First or
Least Significant Byte First.
The character octet itself will appear in the least significant position.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l41">Bit Extraction Operators</A>
</BIG>
</STRONG>
</CENTER>
<P>
The "extract" operators ("&lt;", "&gt;" and "^") are essentially shorthand for
a right shift (to move the bits of interest to the least significant
bit positions) followed by a bitwise AND (to set the bits not of interest
to zero).
The resultant value is a full 32 bits long (and usually a positive integer).
<P>
Since HXA only supports 32-bit values, any attempt to extract bits from
positions greater than 32 always yields a value of zero.
<P>
Operators
<UL>
<LI>
"&lt;" - extract least significant "byte" of "long"
<LI>
"&gt;" - extract most significant "byte" of least significant "word" of "long"
<LI>
"^" - extract most significant "word" of "long"
</UL>
<P>
<TABLE ALIGN=CENTER BORDER=1 CELLPADDING=2>
<CAPTION>Bits Extracted for Byte Size</CAPTION>
<TR ALIGN=CENTER>
<TD>
-
<TD>
<STRONG>8 Bits</STRONG>
<TD>
<STRONG>16 Bits</STRONG>
<TD>
<STRONG>32 Bits</STRONG>
<TR ALIGN=CENTER>
<TD>
&lt;
<TD>
7..0
<TD>
15..0
<TD>
31..0
<TR ALIGN=CENTER>
<TD>
&gt;
<TD>
15..8
<TD>
31..16
<TD>
yields zero
<TR ALIGN=CENTER>
<TD>
^
<TD>
31..16
<TD>
yields zero
<TD>
yields zero
</TABLE>
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P>
<P><HR WIDTH=25%>
<P>
<CENTER>
<STRONG>
<BIG>
<A NAME="l45">Hexadecimal Output Files</A>
</BIG>
</STRONG>
</CENTER>
<P>
<A HREF="hxa_ihex.htm#l03">Intel Hexadecimal Object File Format</A>
 Base Description
<P>
<A HREF="hxa_mhex.htm#l03">Motorola Hexadecimal Object File Format</A>
 Base Description
<P>
Hexadecimal output files are modified in a non-standard way
for 16- and 32-bit byte sizes.
Generally, the record mark character is changed to indicate a non-standard
byte size.
Whatever the byte size, all addresses contained in records are correct
for that size.
<P>
<CENTER>
<A HREF="#top">Page Top</A>
</CENTER>
<P><HR WIDTH=50%>
<EM>Last revised: Tue Sep 17 11:22:41 2013</EM>
</BODY>
</HTML>
